options:
  parameters:
    author: malindatemp
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: base_flowgraph
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 12]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\nimport\
      \ zmq\n\ndef byte_list_to_bitstring(int_arr):\n    return ''.join(f'{b:08b}'\
      \ for b in int_arr)\n\ndef bit_string_to_byte_list(bits):\n    if len(bits)\
      \ % 8 != 0:\n        raise ValueError(\"length not multiple of 8\")\n    return\
      \ [int(bits[i:i+8], 2) for i in range(0, len(bits), 8)]\n\ndef msg_string_to_bitstring(msg_str):\n\
      \    bits = ''.join(f'{b:08b}' for b in msg_str.encode('utf-8'))\n    return\
      \ bits\n\ndef bitstring_to_text(bits, encoding='utf-8'):\n    if len(bits) %\
      \ 8 != 0:\n        raise ValueError(\"Bitstring length must be a multiple of\
      \ 8\")\n    data = bytes(int(bits[i:i+8], 2) for i in range(0, len(bits), 8))\n\
      \    return data.decode(encoding)\n\nclass blk(gr.basic_block):  \n\n    def\
      \ __init__(self, example_param=1.0):  \n        \"\"\"arguments to this function\
      \ show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n    \
      \        self,\n            name='Base_Station_Processor',   \n            in_sig=[],\n\
      \            out_sig=[]\n        )\n\n        # ui sockets\n        self.context\
      \ = zmq.Context.instance()\n\n        self.feedback_push_sock = self.context.socket(zmq.PUSH)\n\
      \        self.feedback_push_sock.bind(\"tcp://localhost:5557\")\n\n        self.msg_to_ui_sock\
      \ = self.context.socket(zmq.PUSH)\n        self.msg_to_ui_sock.bind(\"tcp://localhost:5556\"\
      )\n\n        # misc\n        self.transmit_func_busy = False\n        \n   \
      \     # types\n        self.pkt_data = '00'\n        self.pkt_ack = '11'\n\n\
      \        # my address\n        self.my_address = '00'\n\n        # user node\
      \ addresses\n        self.addrs = {\"User 1\": '01', \"User 2\": '10', \"User\
      \ 3\": '11'}\n        self.users = {'01': 'user1', '10': 'user2', '11': 'user3'}\n\
      \n        # for ack purposes\n        self.ack_received = False # the TX will\
      \ know that an ack was received using this variable, then it reads the received_seq_number\n\
      \        self.received_ack_seq_number = 0\n        self.current_receiver = ''\
      \ # use this for debug purposes \n\n        \n\n        # defining ports\n \
      \       self.message_port_register_in(pmt.intern('Msg_in'))\n        self.message_port_register_out(pmt.intern('Msg_out'))\n\
      \        self.message_port_register_out(pmt.intern('feedback'))\n        self.message_port_register_out(pmt.intern('Pkt_out'))\n\
      \        self.message_port_register_in(pmt.intern('Pkt_in'))\n\n        self.set_msg_handler(pmt.intern('Pkt_in'),\
      \ self.inbound_pkt_handler)\n    \n    def crc_check(self, bitstring):\n   \
      \     pass\n\n    def create_packet(self, tpe, dest_addr, src_addr, seq_no,\
      \ payload=\"\"):\n        packet_str = tpe + dest_addr + src_addr + seq_no +\
      \ payload\n        return packet_str\n    \n    def transmit(self, pkt_string):\n\
      \        try:\n            int_arr = bit_string_to_byte_list(pkt_string)\n \
      \           vec = pmt.init_u8vector(len(int_arr), int_arr)\n            pdu\
      \ = pmt.cons(pmt.PMT_NIL, vec)\n\n            self.message_port_pub(pmt.intern('Pkt_out'),\
      \ pdu)\n        except Exception as e:\n            print(f\"Custom_error: Error\
      \ transmitting packet: {e}\")\n\n\n    def inbound_pkt_handler(self, pkt):\n\
      \        # assuming the packet is a uint\n        if not pmt.is_pair(pkt):\n\
      \            return\n        vec = pmt.cdr(pkt)\n        if not pmt.is_u8vector(vec):\n\
      \            return\n        \n        data_arr = pmt.u8vector_elements(vec)\n\
      \        pkt_bitstring = byte_list_to_bitstring(data_arr)\n\n        pkt_type\
      \ = pkt_bitstring[:2]\n        pkt_dest_addr = pkt_bitstring[2:4]\n        pkt_src_addr\
      \ = pkt_bitstring[4:6]\n        pkt_seq_num = pkt_bitstring[6:8]\n        pkt_payload\
      \ = pkt_bitstring[8:]\n\n        if (pkt_type == self.pkt_data): # the pkt received\
      \ is a data packet\n            if (pkt_dest_addr == self.my_address):\n   \
      \             pkt_str = self.create_packet(self.pkt_ack, pkt_src_addr, pkt_dest_addr,\
      \ pkt_seq_num + 1)\n                while (self.transmit_func_busy == True):\n\
      \                    print(\"base_RX: waiting for transmit to free\")\n    \
      \                continue\n                self.transmit_func_busy = True\n\
      \                self.transmit(pkt_str)\n                self.transmit_func_busy\
      \ = False\n                payload_text = bitstring_to_text(pkt_payload)\n \
      \               \n                \n                text = self.users[pkt_src_addr]\
      \ + payload_text\n\n                # creating the pdu to send to UI\n     \
      \           # text_b = text.encode(\"utf-8\")\n                # pdu = pmt.cons(pmt.PMT_NIL,\
      \ pmt.init_u8vector(len(text_b), bytearray(text_b)))\n                # self.message_port_pub(pmt.intern('Msg_out'),\
      \ pdu)\n\n                # send message to ui\n                self.msg_to_ui_sock.send_string(text)\n\
      \n                # sending feedback to ui\n                self.feedback_push_sock.send_string(\"\
      True\")\n\n            else:\n                # the packet is not meant for\
      \ me\n                return\n        elif (pkt_type == self.pkt_ack): # the\
      \ pkt received is a ack packet\n            if (pkt_dest_addr == self.my_address):\n\
      \                self.current_receiver = self.users[pkt_src_addr]\n        \
      \        self.received_ack_seq_number = pkt_seq_num\n                self.ack_received\
      \ = True\n                if (pkt_payload != ''):\n                    raise\
      \ ValueError(f\"malinda's custom error: an acknowledgement packet cannot have\
      \ a payload\")\n            else:\n                # the packet is not meant\
      \ for me\n                # POSSIBLE ERROR PLACE, PLEASE CHECK WHEN TESING\n\
      \                return\n        else:\n            raise ValueError(f\"malinda's\
      \ custom error: {pkt_type} is not a valid type\")\n        \n    \n    \n\n\n\
      \n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Base_Station_Processor', 'blk', [('example_param', '1.0')], [('Pkt_in',
      'message', 1), ('Msg_in', 'message', 1)], [('Pkt_out', 'message', 1), ('feedback',
      'message', 1), ('Msg_out', 'message', 1)], 'arguments to this function show
      up as parameters in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1192, 308.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import threading\nimport zmq\nimport pmt\nfrom gnuradio import\
      \ gr\nimport json\n\nclass blk(gr.basic_block):\n    \"\"\"\n    ZMQ PULL ->\
      \ GNU Radio PDU (meta=PMT_NIL, data=u8vector)\n    Accepts raw bytes/strings\
      \ from external senders without PMT serialization.\n    \"\"\"\n\n    def __init__(self,\
      \ endpoint='tcp://127.0.0.1:5555', bind=False, rcv_timeout_ms=100):\n      \
      \  gr.basic_block.__init__(self, name=\"pyzmq_pull\", in_sig=[], out_sig=[])\n\
      \n        # Params (editable in GRC via block args if you expose them)\n   \
      \     self.endpoint = endpoint\n        self.bind = bool(bind)\n        self.rcv_timeout_ms\
      \ = int(rcv_timeout_ms)\n\n        # Message out port\n        self.message_port_register_out(pmt.intern(\"\
      out\"))\n\n        # ZMQ state\n        self._ctx = None\n        self._sock\
      \ = None\n        self._thread = None\n        self._running = threading.Event()\n\
      \n    # Start/stop are the right places to spin threads/sockets in GNU Radio\n\
      \    def start(self):\n        self._ctx = zmq.Context.instance()\n        self._sock\
      \ = self._ctx.socket(zmq.PULL)\n\n        # Tame shutdown and avoid hangs\n\
      \        self._sock.setsockopt(zmq.LINGER, 0)\n        self._sock.setsockopt(zmq.RCVTIMEO,\
      \ self.rcv_timeout_ms)\n        # Optional HWM if you want tighter buffering:\n\
      \        # self._sock.setsockopt(zmq.RCVHWM, 100)\n\n        if self.bind:\n\
      \            # Bind (listener)\n            self._sock.bind(self.endpoint) \
      \          # e.g., \"tcp://*:5555\"\n        else:\n            # Connect (dialer)\n\
      \            self._sock.connect(self.endpoint)        # e.g., \"tcp://127.0.0.1:5555\"\
      \n\n        self._running.set()\n        self._thread = threading.Thread(target=self._rx_loop,\
      \ daemon=True)\n        self._thread.start()\n        return super().start()\n\
      \n    def stop(self):\n        self._running.clear()\n        try:\n       \
      \     if self._thread:\n                self._thread.join(timeout=1.0)\n   \
      \     except Exception:\n            pass\n        try:\n            if self._sock:\n\
      \                self._sock.close(0)\n        except Exception:\n          \
      \  pass\n        # Don\u2019t terminate the shared context; other blocks may\
      \ use it\n        self._ctx = None\n        self._sock = None\n        return\
      \ super().stop()\n\n    def _rx_loop(self):\n        while self._running.is_set():\n\
      \            try:\n                # Receive one ZMQ frame (bytes). Works with\
      \ send(), send_string(), send_json() etc.\n                frame = self._sock.recv()\
      \  # bytes; RCVTIMEO makes this return after timeout\n            except zmq.Again:\n\
      \                continue  # timeout, loop again\n            except Exception\
      \ as e:\n                print(\"[pyzmq_pull] recv error:\", e)\n          \
      \      break\n\n            if not frame:\n                continue\n      \
      \      \n            message = frame.decode(\"utf-8\")\n            message\
      \ = pmt.intern(message)\n            pdu = pmt.cons(pmt.PMT_NIL, message)\n\
      \            self.message_port_pub(pmt.intern(\"out\"), pdu)\n"
    affinity: ''
    alias: ''
    bind: 'True'
    comment: ''
    endpoint: '''tcp://127.0.0.1:5555'''
    maxoutbuf: '0'
    minoutbuf: '0'
    rcv_timeout_ms: '100'
  states:
    _io_cache: ('pyzmq_pull', 'blk', [('endpoint', "'tcp://127.0.0.1:5555'"), ('bind',
      'False'), ('rcv_timeout_ms', '100')], [], [('out', 'message', 1)], '\n    ZMQ
      PULL -> GNU Radio PDU (meta=PMT_NIL, data=u8vector)\n    Accepts raw bytes/strings
      from external senders without PMT serialization.\n    ', ['bind', 'endpoint',
      'rcv_timeout_ms'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [544, 252.0]
    rotation: 0
    state: enabled
connections: []

metadata:
  file_format: 1
  grc_version: 3.10.12.0
