options:
  parameters:
    author: malindatemp
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: base_flowgraph
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 12]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport pmt\n\n\nclass blk(gr.basic_block):  \n    \"\
      \"\"Embedded Python Block example - a simple multiply const\"\"\"\n\n    def\
      \ __init__(self, example_param=1.0):  \n        \"\"\"arguments to this function\
      \ show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n    \
      \        self,\n            name='Base_Station_Processor',   \n            in_sig=[],\n\
      \            out_sig=[]\n        )\n        \n\n        # defining ports\n \
      \       self.message_port_register_in(pmt.intern('Msg_in'))\n        self.message_port_register_out(pmt.intern('Msg_out'))\n\
      \        self.message_port_register_out(pmt.intern('feedback'))\n        self.message_port_register_out(pmt.intern('Pkt_out'))\n\
      \        self.message_port_register_in(pmt.intern('Pkt_in'))\n\n\n\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Base_Station_Processor', 'blk', [('example_param', '1.0')], [('Pkt_in',
      'message', 1), ('Msg_in', 'message', 1)], [('Pkt_out', 'message', 1), ('feedback',
      'message', 1), ('Msg_out', 'message', 1)], 'Embedded Python Block example -
      a simple multiply const', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1192, 308.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import threading\nimport zmq\nimport pmt\nfrom gnuradio import\
      \ gr\nimport json\n\nclass blk(gr.basic_block):\n    \"\"\"\n    ZMQ PULL ->\
      \ GNU Radio PDU (meta=PMT_NIL, data=u8vector)\n    Accepts raw bytes/strings\
      \ from external senders without PMT serialization.\n    \"\"\"\n\n    def __init__(self,\
      \ endpoint='tcp://127.0.0.1:5555', bind=False, rcv_timeout_ms=100):\n      \
      \  gr.basic_block.__init__(self, name=\"pyzmq_pull\", in_sig=[], out_sig=[])\n\
      \n        # Params (editable in GRC via block args if you expose them)\n   \
      \     self.endpoint = endpoint\n        self.bind = bool(bind)\n        self.rcv_timeout_ms\
      \ = int(rcv_timeout_ms)\n\n        # Message out port\n        self.message_port_register_out(pmt.intern(\"\
      out\"))\n\n        # ZMQ state\n        self._ctx = None\n        self._sock\
      \ = None\n        self._thread = None\n        self._running = threading.Event()\n\
      \n    # Start/stop are the right places to spin threads/sockets in GNU Radio\n\
      \    def start(self):\n        self._ctx = zmq.Context.instance()\n        self._sock\
      \ = self._ctx.socket(zmq.PULL)\n\n        # Tame shutdown and avoid hangs\n\
      \        self._sock.setsockopt(zmq.LINGER, 0)\n        self._sock.setsockopt(zmq.RCVTIMEO,\
      \ self.rcv_timeout_ms)\n        # Optional HWM if you want tighter buffering:\n\
      \        # self._sock.setsockopt(zmq.RCVHWM, 100)\n\n        if self.bind:\n\
      \            # Bind (listener)\n            self._sock.bind(self.endpoint) \
      \          # e.g., \"tcp://*:5555\"\n        else:\n            # Connect (dialer)\n\
      \            self._sock.connect(self.endpoint)        # e.g., \"tcp://127.0.0.1:5555\"\
      \n\n        self._running.set()\n        self._thread = threading.Thread(target=self._rx_loop,\
      \ daemon=True)\n        self._thread.start()\n        return super().start()\n\
      \n    def stop(self):\n        self._running.clear()\n        try:\n       \
      \     if self._thread:\n                self._thread.join(timeout=1.0)\n   \
      \     except Exception:\n            pass\n        try:\n            if self._sock:\n\
      \                self._sock.close(0)\n        except Exception:\n          \
      \  pass\n        # Don\u2019t terminate the shared context; other blocks may\
      \ use it\n        self._ctx = None\n        self._sock = None\n        return\
      \ super().stop()\n\n    def _rx_loop(self):\n        while self._running.is_set():\n\
      \            try:\n                # Receive one ZMQ frame (bytes). Works with\
      \ send(), send_string(), send_json() etc.\n                frame = self._sock.recv()\
      \  # bytes; RCVTIMEO makes this return after timeout\n            except zmq.Again:\n\
      \                continue  # timeout, loop again\n            except Exception\
      \ as e:\n                print(\"[pyzmq_pull] recv error:\", e)\n          \
      \      break\n\n            if not frame:\n                continue\n      \
      \      \n            message = frame.decode(\"utf-8\")\n            message\
      \ = pmt.intern(message)\n            pdu = pmt.cons(pmt.PMT_NIL, message)\n\
      \            self.message_port_pub(pmt.intern(\"out\"), pdu)\n"
    affinity: ''
    alias: ''
    bind: 'True'
    comment: ''
    endpoint: '''tcp://127.0.0.1:5555'''
    maxoutbuf: '0'
    minoutbuf: '0'
    rcv_timeout_ms: '100'
  states:
    _io_cache: ('pyzmq_pull', 'blk', [('endpoint', "'tcp://127.0.0.1:5555'"), ('bind',
      'False'), ('rcv_timeout_ms', '100')], [], [('out', 'message', 1)], '\n    ZMQ
      PULL -> GNU Radio PDU (meta=PMT_NIL, data=u8vector)\n    Accepts raw bytes/strings
      from external senders without PMT serialization.\n    ', ['bind', 'endpoint',
      'rcv_timeout_ms'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [544, 252.0]
    rotation: 0
    state: enabled
connections: []

metadata:
  file_format: 1
  grc_version: 3.10.12.0
