options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: threading1
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 12.0]
    rotation: 0
    state: enabled

blocks:
- name: access_key
  id: variable
  parameters:
    comment: ''
    value: '''11100001010110101110100010010011'''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [504, 12.0]
    rotation: 0
    state: enabled
- name: excess_bw
  id: variable
  parameters:
    comment: ''
    value: '0.35'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [712, 12.0]
    rotation: 0
    state: enabled
- name: freq1
  id: variable
  parameters:
    comment: ''
    value: 1.2e9
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1520, 12.0]
    rotation: 0
    state: enabled
- name: freq2
  id: variable
  parameters:
    comment: ''
    value: 5.8e9
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1608, 12.0]
    rotation: 0
    state: enabled
- name: freq_offset
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: Frequency Offset
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '-0.1'
    step: '0.001'
    stop: '0.1'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 96.0]
    rotation: 0
    state: enabled
- name: hdr_format
  id: variable
  parameters:
    comment: header_format_default
    value: digital.header_format_default(access_key, 0)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [296, 12.0]
    rotation: 0
    state: enabled
- name: nfilts
  id: variable
  parameters:
    comment: ''
    value: '32'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1152, 12.0]
    rotation: 0
    state: enabled
- name: noise_volt
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: Noise Voltage
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '0.01'
    stop: '1'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [504, 96.0]
    rotation: 0
    state: enabled
- name: phase_bw
  id: variable
  parameters:
    comment: ''
    value: '0.0628'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1416, 12.0]
    rotation: 0
    state: enabled
- name: qpsk
  id: variable_constellation_rect
  parameters:
    comment: ''
    const_points: '[0.707+0.707j, -0.707+0.707j, -0.707-0.707j, 0.707-0.707j]'
    imag_sect: '2'
    precision: '8'
    real_sect: '2'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 2, 3]'
    w_imag_sect: '1'
    w_real_sect: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 108.0]
    rotation: 0
    state: enabled
- name: rrc_taps
  id: variable
  parameters:
    comment: ''
    value: firdes.root_raised_cosine(nfilts, nfilts, 1.0/float(sps), 0.35, 11*sps*nfilts)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1232, 12.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [192, 12.0]
    rotation: 0
    state: enabled
- name: sps
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [816, 12.0]
    rotation: 0
    state: enabled
- name: taps
  id: variable
  parameters:
    comment: ''
    value: '[1.0 + 0.0j, ]'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1072, 12.0]
    rotation: 0
    state: enabled
- name: thresh
  id: variable
  parameters:
    comment: ''
    value: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [992, 12.0]
    rotation: 0
    state: enabled
- name: time_offset
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: Timing Offset
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0.999'
    step: '0.0001'
    stop: '1.001'
    value: '1.000'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [664, 96.0]
    rotation: 0
    state: enabled
- name: usrp_rate
  id: variable
  parameters:
    comment: ''
    value: '768000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [896, 12.0]
    rotation: 0
    state: enabled
- name: variable_adaptive_algorithm_0
  id: variable_adaptive_algorithm
  parameters:
    comment: ''
    cons: qpsk
    delta: '10.0'
    ffactor: '0.99'
    modulus: '4'
    step_size: '.0001'
    type: cma
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [208, 108.0]
    rotation: 0
    state: enabled
- name: blocks_message_debug_0
  id: blocks_message_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    en_uvec: 'True'
    log_level: info
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [944, 1464.0]
    rotation: 0
    state: enabled
- name: blocks_message_debug_0_0
  id: blocks_message_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    en_uvec: 'True'
    log_level: info
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [936, 816.0]
    rotation: 0
    state: enabled
- name: blocks_message_strobe_0
  id: blocks_message_strobe
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    msg: pmt.intern("2:Hello from A")
    period: '1000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [112, 876.0]
    rotation: 0
    state: disabled
- name: blocks_message_strobe_0_0
  id: blocks_message_strobe
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    msg: pmt.intern("1:Hello from B")
    period: '1000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [136, 1572.0]
    rotation: 0
    state: disabled
- name: blocks_repack_bits_bb_1_0_0
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: MSB
    endianness: gr.GR_MSB_FIRST
    k: '1'
    l: '8'
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [768, 1036.0]
    rotation: 180
    state: true
- name: blocks_repack_bits_bb_1_0_0_0
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: MSB
    endianness: gr.GR_MSB_FIRST
    k: '1'
    l: '8'
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 356.0]
    rotation: 180
    state: true
- name: blocks_tagged_stream_mux_0
  id: blocks_tagged_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: packet_len
    maxoutbuf: '0'
    minoutbuf: '0'
    ninputs: '2'
    tag_preserve_head_pos: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1408, 624.0]
    rotation: 0
    state: true
- name: blocks_tagged_stream_mux_0_0
  id: blocks_tagged_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: packet_len
    maxoutbuf: '0'
    minoutbuf: '0'
    ninputs: '2'
    tag_preserve_head_pos: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1432, 1312.0]
    rotation: 0
    state: true
- name: blocks_unpack_k_bits_bb_0
  id: blocks_unpack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1392, 1048.0]
    rotation: 180
    state: enabled
- name: blocks_unpack_k_bits_bb_0_0
  id: blocks_unpack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1352, 368.0]
    rotation: 180
    state: enabled
- name: digital_constellation_decoder_cb_0_1
  id: digital_constellation_decoder_cb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2040, 1048.0]
    rotation: 180
    state: enabled
- name: digital_constellation_decoder_cb_0_1_0
  id: digital_constellation_decoder_cb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1984, 368.0]
    rotation: 180
    state: enabled
- name: digital_constellation_modulator_0_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    differential: 'True'
    excess_bw: excess_bw
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: sps
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1680, 604.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0_0_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    differential: 'True'
    excess_bw: excess_bw
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: sps
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1712, 1292.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_xx_ts_0
  id: digital_correlate_access_code_xx_ts
  parameters:
    access_code: '"11100001010110101110100010010011"'
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: packet_len
    threshold: thresh
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1032, 1028.0]
    rotation: 180
    state: true
- name: digital_correlate_access_code_xx_ts_0_0
  id: digital_correlate_access_code_xx_ts
  parameters:
    access_code: '"11100001010110101110100010010011"'
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: packet_len
    threshold: thresh
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1000, 348.0]
    rotation: 180
    state: true
- name: digital_costas_loop_cc_0_1
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '4'
    use_snr: 'False'
    w: phase_bw
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2368, 1056.0]
    rotation: 180
    state: enabled
- name: digital_costas_loop_cc_0_1_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '4'
    use_snr: 'False'
    w: phase_bw
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2328, 376.0]
    rotation: 180
    state: enabled
- name: digital_diff_decoder_bb_0_1
  id: digital_diff_decoder_bb
  parameters:
    affinity: ''
    alias: ''
    coding: digital.DIFF_DIFFERENTIAL
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    modulus: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1800, 1036.0]
    rotation: 180
    state: enabled
- name: digital_diff_decoder_bb_0_1_0
  id: digital_diff_decoder_bb
  parameters:
    affinity: ''
    alias: ''
    coding: digital.DIFF_DIFFERENTIAL
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    modulus: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1736, 356.0]
    rotation: 180
    state: enabled
- name: digital_linear_equalizer_0
  id: digital_linear_equalizer
  parameters:
    adapt_after_training: 'True'
    affinity: ''
    alg: variable_adaptive_algorithm_0
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_taps: '15'
    sps: '2'
    training_sequence: '[ ]'
    training_start_tag: corr_est
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2608, 408.0]
    rotation: 180
    state: enabled
- name: digital_linear_equalizer_0_0
  id: digital_linear_equalizer
  parameters:
    adapt_after_training: 'True'
    affinity: ''
    alg: variable_adaptive_algorithm_0
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_taps: '15'
    sps: '2'
    training_sequence: '[ ]'
    training_start_tag: corr_est
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2656, 1088.0]
    rotation: 180
    state: enabled
- name: digital_map_bb_0_1
  id: digital_map_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    map: '[0,1,2,3]'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1600, 1048.0]
    rotation: 180
    state: enabled
- name: digital_map_bb_0_1_0
  id: digital_map_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    map: '[0,1,2,3]'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1544, 368.0]
    rotation: 180
    state: enabled
- name: digital_pfb_clock_sync_xxx_0
  id: digital_pfb_clock_sync_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    filter_size: nfilts
    init_phase: nfilts/2
    loop_bw: phase_bw
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    osps: '2'
    sps: sps
    taps: rrc_taps
    type: ccf
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2904, 424.0]
    rotation: 180
    state: enabled
- name: digital_pfb_clock_sync_xxx_0_0
  id: digital_pfb_clock_sync_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    filter_size: nfilts
    init_phase: nfilts/2
    loop_bw: phase_bw
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    osps: '2'
    sps: sps
    taps: rrc_taps
    type: ccf
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2960, 1104.0]
    rotation: 180
    state: enabled
- name: digital_protocol_formatter_async_0
  id: digital_protocol_formatter_async
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    format: hdr_format
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [768, 624.0]
    rotation: 0
    state: enabled
- name: digital_protocol_formatter_async_0_0
  id: digital_protocol_formatter_async
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    format: hdr_format
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [792, 1320.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Block for GNU Radio - Mesh Network Packet\
      \ Communication\nImplements packetization, Stop-and-Wait ARQ, and ALOHA collision\
      \ avoidance\nNo external CRC module required - implements CRC-16 CCITT manually\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\nimport threading\n\
      import queue\nimport time\nimport random\nimport struct\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"\n    Mesh Network Packet Communication Block\n    Handles packet\
      \ transmission/reception with Stop-and-Wait ARQ\n    \"\"\"\n    \n    def __init__(self,\
      \ node_id=1, aloha_prob=0.3, timeout=1.0, max_retries=3):\n        \"\"\"\n\
      \        Arguments:\n            node_id: Unique identifier for this node (1-255)\n\
      \            aloha_prob: Transmission probability for ALOHA (0.0-1.0)\n    \
      \        timeout: ARQ timeout in seconds\n            max_retries: Maximum retransmission\
      \ attempts\n        \"\"\"\n        gr.sync_block.__init__(\n            self,\n\
      \            name='Mesh Packet Comm',\n            in_sig=None,\n          \
      \  out_sig=None\n        )\n        \n        # Node configuration\n       \
      \ self.node_id = node_id\n        self.aloha_prob = aloha_prob\n        self.timeout\
      \ = timeout\n        self.max_retries = max_retries\n        \n        # Packet\
      \ parameters\n        self.PREAMBLE = bytes([0xAA, 0xAA, 0xAA, 0xAA])\n    \
      \    self.SYNC_WORD = bytes([0x2D, 0xD4])\n        self.MAX_PAYLOAD = 255\n\
      \        self.HEADER_SIZE = 8  # preamble(4) + sync(2) + src(1) + dst(1)\n \
      \       self.CRC_SIZE = 2\n        \n        # Packet types\n        self.PKT_DATA\
      \ = 0x01\n        self.PKT_ACK = 0x02\n        \n        # CRC-16 CCITT lookup\
      \ table\n        self.crc_table = self.generate_crc_table()\n        \n    \
      \    # State management\n        self.tx_queue = queue.Queue()\n        self.rx_queue\
      \ = queue.Queue()\n        self.ack_queue = queue.Queue()\n        self.pending_ack\
      \ = {}\n        self.seq_num_tx = 0\n        self.seq_num_rx = {}\n        self.rx_buffer\
      \ = bytes()\n        \n        # Statistics\n        self.stats = {\n      \
      \      'packets_sent': 0,\n            'packets_received': 0,\n            'acks_sent':\
      \ 0,\n            'acks_received': 0,\n            'retransmissions': 0,\n \
      \           'crc_errors': 0\n        }\n        \n        # Threading\n    \
      \    self.running = True\n        self.tx_thread = threading.Thread(target=self.tx_handler)\n\
      \        self.rx_thread = threading.Thread(target=self.rx_handler)\n       \
      \ self.lock = threading.Lock()\n        \n        # Message ports\n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        self.message_port_register_in(pmt.intern('pdu_in'))\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        self.message_port_register_out(pmt.intern('pdu_out'))\n        self.message_port_register_out(pmt.intern('feedback'))\n\
      \        \n        # Set message handlers\n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg_in)\n        self.set_msg_handler(pmt.intern('pdu_in'), self.handle_pdu_in)\n\
      \        \n        # Start threads\n        self.tx_thread.start()\n       \
      \ self.rx_thread.start()\n        \n        print(f\"[Node {self.node_id}] Initialized\
      \ - Ready for communication\")\n    \n    def generate_crc_table(self):\n  \
      \      \"\"\"Generate CRC-16 CCITT lookup table\"\"\"\n        poly = 0x1021\n\
      \        table = []\n        for i in range(256):\n            crc = i << 8\n\
      \            for j in range(8):\n                if crc & 0x8000:\n        \
      \            crc = ((crc << 1) ^ poly) & 0xFFFF\n                else:\n   \
      \                 crc = (crc << 1) & 0xFFFF\n            table.append(crc)\n\
      \        return table\n    \n    def calculate_crc16(self, data):\n        \"\
      \"\"Calculate CRC-16 CCITT for given data\"\"\"\n        crc = 0xFFFF\n    \
      \    for byte in data:\n            tbl_idx = ((crc >> 8) ^ byte) & 0xFF\n \
      \           crc = ((crc << 8) ^ self.crc_table[tbl_idx]) & 0xFFFF\n        return\
      \ crc\n    \n    def handle_msg_in(self, msg):\n        \"\"\"Handle incoming\
      \ messages from GUI/application\"\"\"\n        try:\n            # Handle string\
      \ messages directly\n            if pmt.is_symbol(msg):\n                # Simple\
      \ text message format: \"dst_id:message\"\n                text = pmt.symbol_to_string(msg)\n\
      \                if ':' in text:\n                    parts = text.split(':',\
      \ 1)\n                    try:\n                        dst_id = int(parts[0])\n\
      \                        data = parts[1].encode()\n                        self.tx_queue.put({'dst':\
      \ dst_id, 'data': data, 'type': self.PKT_DATA})\n                        print(f\"\
      [Node {self.node_id}] Queued message to {dst_id}: {parts[1]}\")\n          \
      \          except ValueError:\n                        print(f\"[Node {self.node_id}]\
      \ Invalid destination ID\")\n            \n            # Handle dictionary messages\n\
      \            elif pmt.is_dict(msg):\n                meta = pmt.to_python(msg)\n\
      \                if 'dst' in meta and 'data' in meta:\n                    dst_id\
      \ = meta['dst']\n                    data = meta['data'].encode() if isinstance(meta['data'],\
      \ str) else meta['data']\n                    self.tx_queue.put({'dst': dst_id,\
      \ 'data': data, 'type': self.PKT_DATA})\n                    print(f\"[Node\
      \ {self.node_id}] Queued message to {dst_id}\")\n            \n            #\
      \ Handle pair messages (PDU format)\n            elif pmt.is_pair(msg):\n  \
      \              meta = pmt.to_python(pmt.car(msg))\n                data = pmt.to_python(pmt.cdr(msg))\n\
      \                if isinstance(meta, dict) and 'dst' in meta:\n            \
      \        dst_id = meta['dst']\n                    if isinstance(data, str):\n\
      \                        data = data.encode()\n                    elif isinstance(data,\
      \ list):\n                        data = bytes(data)\n                    self.tx_queue.put({'dst':\
      \ dst_id, 'data': data, 'type': self.PKT_DATA})\n                    print(f\"\
      [Node {self.node_id}] Queued message to {dst_id}\")\n                    \n\
      \        except Exception as e:\n            print(f\"[Node {self.node_id}]\
      \ Error handling msg_in: {e}\")\n    \n    def handle_pdu_in(self, pdu):\n \
      \       \"\"\"Handle incoming PDUs from demodulator\"\"\"\n        try:\n  \
      \          # Extract PDU data\n            if pmt.is_pair(pdu):\n          \
      \      meta = pmt.car(pdu)\n                data = pmt.cdr(pdu)\n          \
      \      \n                # Convert to bytes\n                if pmt.is_u8vector(data):\n\
      \                    print(\"loop run\")\t\n                    rx_bytes = bytes(pmt.u8vector_elements(data))\t\
      \n                    self.rx_queue.put(rx_bytes)\n                elif pmt.is_uniform_vector(data):\n\
      \                    # Handle float32 or other vector types\n              \
      \      elements = pmt.to_python(data)\n                    # Convert to bytes\
      \ (assuming 8-bit symbols)\n                    rx_bytes = bytes([int(x) & 0xFF\
      \ for x in elements])\n                    self.rx_queue.put(rx_bytes)\n   \
      \                 \n        except Exception as e:\n            print(f\"[Node\
      \ {self.node_id}] Error handling pdu_in: {e}\")\n    \n    def create_packet(self,\
      \ dst_id, seq_num, pkt_type, payload=b''):\n        \"\"\"Create a packet with\
      \ headers and CRC\"\"\"\n        packet = bytearray()\n        \n        # Add\
      \ preamble and sync word\n        packet.extend(self.PREAMBLE)\n        packet.extend(self.SYNC_WORD)\n\
      \        \n        # Add header\n        packet.append(self.node_id)  # Source\
      \ ID\n        packet.append(dst_id)         # Destination ID\n        packet.append(seq_num)\
      \        # Sequence number\n        packet.append(pkt_type)       # Packet type\n\
      \        packet.append(len(payload))   # Payload length\n        \n        #\
      \ Add payload\n        if payload:\n            packet.extend(payload[:self.MAX_PAYLOAD])\n\
      \        \n        # Calculate and add CRC16\n        crc_data = bytes(packet[len(self.PREAMBLE)\
      \ + len(self.SYNC_WORD):])\n        crc_val = self.calculate_crc16(crc_data)\n\
      \        packet.extend(struct.pack('>H', crc_val))\n        \n        return\
      \ bytes(packet)\n    \n    def parse_packet(self, data):\n        \"\"\"Parse\
      \ received packet and validate CRC\"\"\"\n        try:\n            # Find sync\
      \ word\n            sync_idx = data.find(self.SYNC_WORD)\n            if sync_idx\
      \ == -1:\n                return None\n            \n            # Check minimum\
      \ packet size\n            start_idx = sync_idx + len(self.SYNC_WORD)\n    \
      \        if len(data) < start_idx + 5 + self.CRC_SIZE:\n                return\
      \ None\n            \n            # Extract header fields\n            src_id\
      \ = data[start_idx]\n            dst_id = data[start_idx + 1]\n            seq_num\
      \ = data[start_idx + 2]\n            pkt_type = data[start_idx + 3]\n      \
      \      payload_len = data[start_idx + 4]\n            \n            # Check\
      \ if we have complete packet\n            total_len = start_idx + 5 + payload_len\
      \ + self.CRC_SIZE\n            if len(data) < total_len:\n                return\
      \ None\n            \n            # Extract payload and CRC\n            payload\
      \ = data[start_idx + 5:start_idx + 5 + payload_len]\n            rx_crc = struct.unpack('>H',\
      \ data[total_len - self.CRC_SIZE:total_len])[0]\n            \n            #\
      \ Verify CRC\n            crc_data = data[start_idx:total_len - self.CRC_SIZE]\n\
      \            calc_crc = self.calculate_crc16(crc_data)\n            \n     \
      \       if rx_crc != calc_crc:\n                self.stats['crc_errors'] +=\
      \ 1\n                print(f\"[Node {self.node_id}] CRC mismatch (expected:\
      \ {calc_crc:04X}, got: {rx_crc:04X})\")\n                return None\n     \
      \       \n            return {\n                'src': src_id,\n           \
      \     'dst': dst_id,\n                'seq': seq_num,\n                'type':\
      \ pkt_type,\n                'payload': payload,\n                'consumed':\
      \ total_len\n            }\n        except Exception as e:\n            print(f\"\
      [Node {self.node_id}] Error parsing packet: {e}\")\n            return None\n\
      \    \n    def tx_handler(self):\n        \"\"\"Thread for handling packet transmission\
      \ with ARQ\"\"\"\n        while self.running:\n            try:\n          \
      \      # Get message from queue (with timeout for thread safety)\n         \
      \       try:\n                    msg = self.tx_queue.get(timeout=0.1)\n   \
      \             except queue.Empty:\n                    continue\n          \
      \      \n                # ALOHA: Random backoff\n                if random.random()\
      \ > self.aloha_prob:\n                    backoff_time = random.uniform(0.1,\
      \ 0.5)\n                    print(f\"[Node {self.node_id}] ALOHA backoff {backoff_time:.2f}s\"\
      )\n                    time.sleep(backoff_time)\n                    # Re-queue\
      \ the message\n                    self.tx_queue.put(msg)\n                \
      \    continue\n                \n                # Prepare packet\n        \
      \        with self.lock:\n                    seq_num = self.seq_num_tx\n  \
      \                  self.seq_num_tx = (self.seq_num_tx + 1) % 256\n         \
      \       \n                packet = self.create_packet(\n                   \
      \ msg['dst'],\n                    seq_num,\n                    msg['type'],\n\
      \                    msg.get('data', b'')\n                )\n             \
      \   \n                # Stop-and-Wait ARQ\n                retries = 0\n   \
      \             ack_received = False\n                \n                while\
      \ retries < self.max_retries and not ack_received:\n                    # Transmit\
      \ packet\n                    print(f\"[Node {self.node_id}] TX: Sending packet\
      \ seq={seq_num} to node {msg['dst']} (attempt {retries + 1})\")\n          \
      \          self.transmit_packet(packet)\n                    self.stats['packets_sent']\
      \ += 1\n                    \n                    if retries > 0:\n        \
      \                self.stats['retransmissions'] += 1\n                    \n\
      \                    # Wait for ACK\n                    ack_key = f\"{msg['dst']}_{seq_num}\"\
      \n                    timeout_time = time.time() + self.timeout\n          \
      \          \n                    while time.time() < timeout_time:\n       \
      \                 try:\n                            ack = self.ack_queue.get(timeout=0.1)\n\
      \                            if ack['key'] == ack_key:\n                   \
      \             ack_received = True\n                                self.stats['acks_received']\
      \ += 1\n                                print(f\"[Node {self.node_id}] TX: ACK\
      \ received for seq={seq_num}\")\n                                output = \"\
      TRUE\"\n                                msg = pmt.intern(output)\n         \
      \                       self.message_port_pub(pmt.intern('feedback'), msg)\n\
      \                                break\n                        except queue.Empty:\n\
      \                            pass\n                    \n                  \
      \  if not ack_received:\n                        retries += 1\n            \
      \            if retries < self.max_retries:\n                            print(f\"\
      [Node {self.node_id}] TX: Timeout, retry {retries}/{self.max_retries}\")\n \
      \               \n                if not ack_received:\n                   \
      \ print(f\"[Node {self.node_id}] TX: Failed to deliver packet seq={seq_num}\
      \ after {self.max_retries} attempts\")\n                    output = \"FALSE\"\
      \n                    msg = pmt.intern(output)\n                    self.message_port_pub(pmt.intern('feedback'),\
      \ msg)\n                    \n            except Exception as e:\n         \
      \       print(f\"[Node {self.node_id}] TX handler error: {e}\")\n    \n    def\
      \ rx_handler(self):\n        \"\"\"Thread for handling packet reception\"\"\"\
      \n        while self.running:\n            try:\n                # Get received\
      \ data\n                try:\n                    rx_data = self.rx_queue.get(timeout=0.1)\n\
      \                except queue.Empty:\n                    continue\n       \
      \         \n                # Add to buffer\n                self.rx_buffer\
      \ += rx_data\n                \n                # Try to parse packets from\
      \ buffer\n                while len(self.rx_buffer) > 0:\n                 \
      \   pkt = self.parse_packet(self.rx_buffer)\n                    \n        \
      \            if pkt is None:\n                        # No valid packet found,\
      \ remove first byte and try again\n                        if len(self.rx_buffer)\
      \ > 1:\n                            self.rx_buffer = self.rx_buffer[1:]\n  \
      \                      else:\n                            self.rx_buffer = bytes()\n\
      \                        continue\n                    \n                  \
      \  # Remove processed packet from buffer\n                    self.rx_buffer\
      \ = self.rx_buffer[pkt['consumed']:]\n                    \n               \
      \     # Check if packet is for this node or broadcast\n                    if\
      \ pkt['dst'] != self.node_id and pkt['dst'] != 0xFF:\n                     \
      \   print(f\"[Node {self.node_id}] RX: Packet not for us (dst={pkt['dst']})\"\
      )\n                        continue\n                    \n                \
      \    # Handle based on packet type\n                    if pkt['type'] == self.PKT_DATA:\n\
      \                        self.stats['packets_received'] += 1\n             \
      \           print(f\"[Node {self.node_id}] RX: Data packet from node {pkt['src']},\
      \ seq={pkt['seq']}\")\n                        \n                        # Check\
      \ for duplicate\n                        is_duplicate = False\n            \
      \            if pkt['src'] in self.seq_num_rx:\n                           \
      \ if self.seq_num_rx[pkt['src']] == pkt['seq']:\n                          \
      \      print(f\"[Node {self.node_id}] RX: Duplicate packet detected\")\n   \
      \                             is_duplicate = True\n                        \n\
      \                        self.seq_num_rx[pkt['src']] = pkt['seq']\n        \
      \                \n                        # Send ACK\n                    \
      \    ack_packet = self.create_packet(\n                            pkt['src'],\n\
      \                            pkt['seq'],\n                            self.PKT_ACK\n\
      \                        )\n                        print(f\"[Node {self.node_id}]\
      \ RX: Sending ACK for seq={pkt['seq']}\")\n                        self.transmit_packet(ack_packet)\n\
      \                        self.stats['acks_sent'] += 1\n                    \
      \    \n                        # Forward to application if not duplicate\n \
      \                       if not is_duplicate:\n                            self.forward_to_app(pkt['src'],\
      \ pkt['payload'])\n                        \n                    elif pkt['type']\
      \ == self.PKT_ACK:\n                        print(f\"[Node {self.node_id}] RX:\
      \ ACK packet from node {pkt['src']}, seq={pkt['seq']}\")\n                 \
      \       # Process ACK\n                        ack_key = f\"{pkt['src']}_{pkt['seq']}\"\
      \n                        self.ack_queue.put({'key': ack_key})\n           \
      \             \n            except Exception as e:\n                print(f\"\
      [Node {self.node_id}] RX handler error: {e}\")\n    \n    def transmit_packet(self,\
      \ packet):\n        \"\"\"Send packet to physical layer\"\"\"\n        try:\n\
      \            # Convert to PDU format\n            vec = pmt.init_u8vector(len(packet),\
      \ list(packet))\n            pdu = pmt.cons(pmt.PMT_NIL, vec)\n            \n\
      \            # Send to modulator\n            self.message_port_pub(pmt.intern('pdu_out'),\
      \ pdu)\n            \n        except Exception as e:\n            print(f\"\
      [Node {self.node_id}] Error transmitting packet: {e}\")\n    \n    def forward_to_app(self,\
      \ src_id, data):\n        \"\"\"Forward received data to application/GUI\"\"\
      \"\n        try:\n            # Decode message\n            message = data.decode('utf-8',\
      \ errors='ignore')\n            \n            # Create formatted output string\n\
      \            output = f\"[From Node {src_id}]: {message}\"\n            \n \
      \           # Send as simple string message\n            msg = pmt.intern(output)\n\
      \            self.message_port_pub(pmt.intern('msg_out'), msg)\n           \
      \ \n            # Also send as dictionary for more complex processing\n    \
      \        meta = pmt.make_dict()\n            meta = pmt.dict_add(meta, pmt.intern(\"\
      src\"), pmt.from_long(src_id))\n            meta = pmt.dict_add(meta, pmt.intern(\"\
      data\"), pmt.intern(message))\n            \n            print(f\"[Node {self.node_id}]\
      \ Message delivered: {output}\")\n            \n        except Exception as\
      \ e:\n            print(f\"[Node {self.node_id}] Error forwarding to app: {e}\"\
      )\n    \n    def work(self, input_items, output_items):\n        \"\"\"Main\
      \ work function (not used for message passing blocks)\"\"\"\n        return\
      \ 0\n    \n    def stop(self):\n        \"\"\"Clean shutdown\"\"\"\n       \
      \ print(f\"\\n[Node {self.node_id}] Statistics:\")\n        print(f\"  Packets\
      \ sent: {self.stats['packets_sent']}\")\n        print(f\"  Packets received:\
      \ {self.stats['packets_received']}\")\n        print(f\"  ACKs sent: {self.stats['acks_sent']}\"\
      )\n        print(f\"  ACKs received: {self.stats['acks_received']}\")\n    \
      \    print(f\"  Retransmissions: {self.stats['retransmissions']}\")\n      \
      \  print(f\"  CRC errors: {self.stats['crc_errors']}\")\n        \n        self.running\
      \ = False\n        if self.tx_thread.is_alive():\n            self.tx_thread.join()\n\
      \        if self.rx_thread.is_alive():\n            self.rx_thread.join()\n\
      \        return True\n"
    affinity: ''
    alias: ''
    aloha_prob: '0.6'
    comment: User 1
    max_retries: '3'
    maxoutbuf: '0'
    minoutbuf: '0'
    node_id: '1'
    timeout: '0.2'
  states:
    _io_cache: ('Mesh Packet Comm', 'blk', [('node_id', '1'), ('aloha_prob', '0.3'),
      ('timeout', '1.0'), ('max_retries', '3')], [('pdu_in', 'message', 1), ('msg_in',
      'message', 1)], [('feedback', 'message', 1), ('pdu_out', 'message', 1), ('msg_out',
      'message', 1)], '\n    Mesh Network Packet Communication Block\n    Handles
      packet transmission/reception with Stop-and-Wait ARQ\n    ', ['aloha_prob',
      'max_retries', 'node_id', 'timeout'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 620.0]
    rotation: 0
    state: enabled
- name: epy_block_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Block for GNU Radio - Mesh Network Packet\
      \ Communication\nImplements packetization, Stop-and-Wait ARQ, and ALOHA collision\
      \ avoidance\nNo external CRC module required - implements CRC-16 CCITT manually\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\nimport threading\n\
      import queue\nimport time\nimport random\nimport struct\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"\n    Mesh Network Packet Communication Block\n    Handles packet\
      \ transmission/reception with Stop-and-Wait ARQ\n    \"\"\"\n    \n    def __init__(self,\
      \ node_id=1, aloha_prob=0.3, timeout=1.0, max_retries=3):\n        \"\"\"\n\
      \        Arguments:\n            node_id: Unique identifier for this node (1-255)\n\
      \            aloha_prob: Transmission probability for ALOHA (0.0-1.0)\n    \
      \        timeout: ARQ timeout in seconds\n            max_retries: Maximum retransmission\
      \ attempts\n        \"\"\"\n        gr.sync_block.__init__(\n            self,\n\
      \            name='Mesh Packet Comm',\n            in_sig=None,\n          \
      \  out_sig=None\n        )\n        \n        # Node configuration\n       \
      \ self.node_id = node_id\n        self.aloha_prob = aloha_prob\n        self.timeout\
      \ = timeout\n        self.max_retries = max_retries\n        \n        # Packet\
      \ parameters\n        self.PREAMBLE = bytes([0xAA, 0xAA, 0xAA, 0xAA])\n    \
      \    self.SYNC_WORD = bytes([0x2D, 0xD4])\n        self.MAX_PAYLOAD = 255\n\
      \        self.HEADER_SIZE = 8  # preamble(4) + sync(2) + src(1) + dst(1)\n \
      \       self.CRC_SIZE = 2\n        \n        # Packet types\n        self.PKT_DATA\
      \ = 0x01\n        self.PKT_ACK = 0x02\n        \n        # CRC-16 CCITT lookup\
      \ table\n        self.crc_table = self.generate_crc_table()\n        \n    \
      \    # State management\n        self.tx_queue = queue.Queue()\n        self.rx_queue\
      \ = queue.Queue()\n        self.ack_queue = queue.Queue()\n        self.pending_ack\
      \ = {}\n        self.seq_num_tx = 0\n        self.seq_num_rx = {}\n        self.rx_buffer\
      \ = bytes()\n        \n        # Statistics\n        self.stats = {\n      \
      \      'packets_sent': 0,\n            'packets_received': 0,\n            'acks_sent':\
      \ 0,\n            'acks_received': 0,\n            'retransmissions': 0,\n \
      \           'crc_errors': 0\n        }\n        \n        # Threading\n    \
      \    self.running = True\n        self.tx_thread = threading.Thread(target=self.tx_handler)\n\
      \        self.rx_thread = threading.Thread(target=self.rx_handler)\n       \
      \ self.lock = threading.Lock()\n        \n        # Message ports\n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        self.message_port_register_in(pmt.intern('pdu_in'))\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        self.message_port_register_out(pmt.intern('pdu_out'))\n        self.message_port_register_out(pmt.intern('feedback'))\n\
      \        \n        # Set message handlers\n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg_in)\n        self.set_msg_handler(pmt.intern('pdu_in'), self.handle_pdu_in)\n\
      \        \n        # Start threads\n        self.tx_thread.start()\n       \
      \ self.rx_thread.start()\n        \n        print(f\"[Node {self.node_id}] Initialized\
      \ - Ready for communication\")\n    \n    def generate_crc_table(self):\n  \
      \      \"\"\"Generate CRC-16 CCITT lookup table\"\"\"\n        poly = 0x1021\n\
      \        table = []\n        for i in range(256):\n            crc = i << 8\n\
      \            for j in range(8):\n                if crc & 0x8000:\n        \
      \            crc = ((crc << 1) ^ poly) & 0xFFFF\n                else:\n   \
      \                 crc = (crc << 1) & 0xFFFF\n            table.append(crc)\n\
      \        return table\n    \n    def calculate_crc16(self, data):\n        \"\
      \"\"Calculate CRC-16 CCITT for given data\"\"\"\n        crc = 0xFFFF\n    \
      \    for byte in data:\n            tbl_idx = ((crc >> 8) ^ byte) & 0xFF\n \
      \           crc = ((crc << 8) ^ self.crc_table[tbl_idx]) & 0xFFFF\n        return\
      \ crc\n    \n    def handle_msg_in(self, msg):\n        \"\"\"Handle incoming\
      \ messages from GUI/application\"\"\"\n        try:\n            # Handle string\
      \ messages directly\n            if pmt.is_symbol(msg):\n                # Simple\
      \ text message format: \"dst_id:message\"\n                text = pmt.symbol_to_string(msg)\n\
      \                if ':' in text:\n                    parts = text.split(':',\
      \ 1)\n                    try:\n                        dst_id = int(parts[0])\n\
      \                        data = parts[1].encode()\n                        self.tx_queue.put({'dst':\
      \ dst_id, 'data': data, 'type': self.PKT_DATA})\n                        print(f\"\
      [Node {self.node_id}] Queued message to {dst_id}: {parts[1]}\")\n          \
      \          except ValueError:\n                        print(f\"[Node {self.node_id}]\
      \ Invalid destination ID\")\n            \n            # Handle dictionary messages\n\
      \            elif pmt.is_dict(msg):\n                meta = pmt.to_python(msg)\n\
      \                if 'dst' in meta and 'data' in meta:\n                    dst_id\
      \ = meta['dst']\n                    data = meta['data'].encode() if isinstance(meta['data'],\
      \ str) else meta['data']\n                    self.tx_queue.put({'dst': dst_id,\
      \ 'data': data, 'type': self.PKT_DATA})\n                    print(f\"[Node\
      \ {self.node_id}] Queued message to {dst_id}\")\n            \n            #\
      \ Handle pair messages (PDU format)\n            elif pmt.is_pair(msg):\n  \
      \              meta = pmt.to_python(pmt.car(msg))\n                data = pmt.to_python(pmt.cdr(msg))\n\
      \                if isinstance(meta, dict) and 'dst' in meta:\n            \
      \        dst_id = meta['dst']\n                    if isinstance(data, str):\n\
      \                        data = data.encode()\n                    elif isinstance(data,\
      \ list):\n                        data = bytes(data)\n                    self.tx_queue.put({'dst':\
      \ dst_id, 'data': data, 'type': self.PKT_DATA})\n                    print(f\"\
      [Node {self.node_id}] Queued message to {dst_id}\")\n                    \n\
      \        except Exception as e:\n            print(f\"[Node {self.node_id}]\
      \ Error handling msg_in: {e}\")\n    \n    def handle_pdu_in(self, pdu):\n \
      \       \"\"\"Handle incoming PDUs from demodulator\"\"\"\n        try:\n  \
      \          # Extract PDU data\n            if pmt.is_pair(pdu):\n          \
      \      meta = pmt.car(pdu)\n                data = pmt.cdr(pdu)\n          \
      \      \n                # Convert to bytes\n                if pmt.is_u8vector(data):\n\
      \                    print(\"loop run\")\t\n                    rx_bytes = bytes(pmt.u8vector_elements(data))\t\
      \n                    self.rx_queue.put(rx_bytes)\n                elif pmt.is_uniform_vector(data):\n\
      \                    # Handle float32 or other vector types\n              \
      \      elements = pmt.to_python(data)\n                    # Convert to bytes\
      \ (assuming 8-bit symbols)\n                    rx_bytes = bytes([int(x) & 0xFF\
      \ for x in elements])\n                    self.rx_queue.put(rx_bytes)\n   \
      \                 \n        except Exception as e:\n            print(f\"[Node\
      \ {self.node_id}] Error handling pdu_in: {e}\")\n    \n    def create_packet(self,\
      \ dst_id, seq_num, pkt_type, payload=b''):\n        \"\"\"Create a packet with\
      \ headers and CRC\"\"\"\n        packet = bytearray()\n        \n        # Add\
      \ preamble and sync word\n        packet.extend(self.PREAMBLE)\n        packet.extend(self.SYNC_WORD)\n\
      \        \n        # Add header\n        packet.append(self.node_id)  # Source\
      \ ID\n        packet.append(dst_id)         # Destination ID\n        packet.append(seq_num)\
      \        # Sequence number\n        packet.append(pkt_type)       # Packet type\n\
      \        packet.append(len(payload))   # Payload length\n        \n        #\
      \ Add payload\n        if payload:\n            packet.extend(payload[:self.MAX_PAYLOAD])\n\
      \        \n        # Calculate and add CRC16\n        crc_data = bytes(packet[len(self.PREAMBLE)\
      \ + len(self.SYNC_WORD):])\n        crc_val = self.calculate_crc16(crc_data)\n\
      \        packet.extend(struct.pack('>H', crc_val))\n        \n        return\
      \ bytes(packet)\n    \n    def parse_packet(self, data):\n        \"\"\"Parse\
      \ received packet and validate CRC\"\"\"\n        try:\n            # Find sync\
      \ word\n            sync_idx = data.find(self.SYNC_WORD)\n            if sync_idx\
      \ == -1:\n                return None\n            \n            # Check minimum\
      \ packet size\n            start_idx = sync_idx + len(self.SYNC_WORD)\n    \
      \        if len(data) < start_idx + 5 + self.CRC_SIZE:\n                return\
      \ None\n            \n            # Extract header fields\n            src_id\
      \ = data[start_idx]\n            dst_id = data[start_idx + 1]\n            seq_num\
      \ = data[start_idx + 2]\n            pkt_type = data[start_idx + 3]\n      \
      \      payload_len = data[start_idx + 4]\n            \n            # Check\
      \ if we have complete packet\n            total_len = start_idx + 5 + payload_len\
      \ + self.CRC_SIZE\n            if len(data) < total_len:\n                return\
      \ None\n            \n            # Extract payload and CRC\n            payload\
      \ = data[start_idx + 5:start_idx + 5 + payload_len]\n            rx_crc = struct.unpack('>H',\
      \ data[total_len - self.CRC_SIZE:total_len])[0]\n            \n            #\
      \ Verify CRC\n            crc_data = data[start_idx:total_len - self.CRC_SIZE]\n\
      \            calc_crc = self.calculate_crc16(crc_data)\n            \n     \
      \       if rx_crc != calc_crc:\n                self.stats['crc_errors'] +=\
      \ 1\n                print(f\"[Node {self.node_id}] CRC mismatch (expected:\
      \ {calc_crc:04X}, got: {rx_crc:04X})\")\n                return None\n     \
      \       \n            return {\n                'src': src_id,\n           \
      \     'dst': dst_id,\n                'seq': seq_num,\n                'type':\
      \ pkt_type,\n                'payload': payload,\n                'consumed':\
      \ total_len\n            }\n        except Exception as e:\n            print(f\"\
      [Node {self.node_id}] Error parsing packet: {e}\")\n            return None\n\
      \    \n    def tx_handler(self):\n        \"\"\"Thread for handling packet transmission\
      \ with ARQ\"\"\"\n        while self.running:\n            try:\n          \
      \      # Get message from queue (with timeout for thread safety)\n         \
      \       try:\n                    msg = self.tx_queue.get(timeout=0.1)\n   \
      \             except queue.Empty:\n                    continue\n          \
      \      \n                # ALOHA: Random backoff\n                if random.random()\
      \ > self.aloha_prob:\n                    backoff_time = random.uniform(0.1,\
      \ 0.5)\n                    print(f\"[Node {self.node_id}] ALOHA backoff {backoff_time:.2f}s\"\
      )\n                    time.sleep(backoff_time)\n                    # Re-queue\
      \ the message\n                    self.tx_queue.put(msg)\n                \
      \    continue\n                \n                # Prepare packet\n        \
      \        with self.lock:\n                    seq_num = self.seq_num_tx\n  \
      \                  self.seq_num_tx = (self.seq_num_tx + 1) % 256\n         \
      \       \n                packet = self.create_packet(\n                   \
      \ msg['dst'],\n                    seq_num,\n                    msg['type'],\n\
      \                    msg.get('data', b'')\n                )\n             \
      \   \n                # Stop-and-Wait ARQ\n                retries = 0\n   \
      \             ack_received = False\n                \n                while\
      \ retries < self.max_retries and not ack_received:\n                    # Transmit\
      \ packet\n                    print(f\"[Node {self.node_id}] TX: Sending packet\
      \ seq={seq_num} to node {msg['dst']} (attempt {retries + 1})\")\n          \
      \          self.transmit_packet(packet)\n                    self.stats['packets_sent']\
      \ += 1\n                    \n                    if retries > 0:\n        \
      \                self.stats['retransmissions'] += 1\n                    \n\
      \                    # Wait for ACK\n                    ack_key = f\"{msg['dst']}_{seq_num}\"\
      \n                    timeout_time = time.time() + self.timeout\n          \
      \          \n                    while time.time() < timeout_time:\n       \
      \                 try:\n                            ack = self.ack_queue.get(timeout=0.1)\n\
      \                            if ack['key'] == ack_key:\n                   \
      \             ack_received = True\n                                self.stats['acks_received']\
      \ += 1\n                                print(f\"[Node {self.node_id}] TX: ACK\
      \ received for seq={seq_num}\")\n                                output = \"\
      TRUE\"\n                                msg = pmt.intern(output)\n         \
      \                       self.message_port_pub(pmt.intern('feedback'), msg)\n\
      \                                break\n                        except queue.Empty:\n\
      \                            pass\n                    \n                  \
      \  if not ack_received:\n                        retries += 1\n            \
      \            if retries < self.max_retries:\n                            print(f\"\
      [Node {self.node_id}] TX: Timeout, retry {retries}/{self.max_retries}\")\n \
      \               \n                if not ack_received:\n                   \
      \ print(f\"[Node {self.node_id}] TX: Failed to deliver packet seq={seq_num}\
      \ after {self.max_retries} attempts\")\n                    output = \"FALSE\"\
      \n                    msg = pmt.intern(output)\n                    self.message_port_pub(pmt.intern('feedback'),\
      \ msg)\n                    \n            except Exception as e:\n         \
      \       print(f\"[Node {self.node_id}] TX handler error: {e}\")\n    \n    def\
      \ rx_handler(self):\n        \"\"\"Thread for handling packet reception\"\"\"\
      \n        while self.running:\n            try:\n                # Get received\
      \ data\n                try:\n                    rx_data = self.rx_queue.get(timeout=0.1)\n\
      \                except queue.Empty:\n                    continue\n       \
      \         \n                # Add to buffer\n                self.rx_buffer\
      \ += rx_data\n                \n                # Try to parse packets from\
      \ buffer\n                while len(self.rx_buffer) > 0:\n                 \
      \   pkt = self.parse_packet(self.rx_buffer)\n                    \n        \
      \            if pkt is None:\n                        # No valid packet found,\
      \ remove first byte and try again\n                        if len(self.rx_buffer)\
      \ > 1:\n                            self.rx_buffer = self.rx_buffer[1:]\n  \
      \                      else:\n                            self.rx_buffer = bytes()\n\
      \                        continue\n                    \n                  \
      \  # Remove processed packet from buffer\n                    self.rx_buffer\
      \ = self.rx_buffer[pkt['consumed']:]\n                    \n               \
      \     # Check if packet is for this node or broadcast\n                    if\
      \ pkt['dst'] != self.node_id and pkt['dst'] != 0xFF:\n                     \
      \   print(f\"[Node {self.node_id}] RX: Packet not for us (dst={pkt['dst']})\"\
      )\n                        continue\n                    \n                \
      \    # Handle based on packet type\n                    if pkt['type'] == self.PKT_DATA:\n\
      \                        self.stats['packets_received'] += 1\n             \
      \           print(f\"[Node {self.node_id}] RX: Data packet from node {pkt['src']},\
      \ seq={pkt['seq']}\")\n                        \n                        # Check\
      \ for duplicate\n                        is_duplicate = False\n            \
      \            if pkt['src'] in self.seq_num_rx:\n                           \
      \ if self.seq_num_rx[pkt['src']] == pkt['seq']:\n                          \
      \      print(f\"[Node {self.node_id}] RX: Duplicate packet detected\")\n   \
      \                             is_duplicate = True\n                        \n\
      \                        self.seq_num_rx[pkt['src']] = pkt['seq']\n        \
      \                \n                        # Send ACK\n                    \
      \    ack_packet = self.create_packet(\n                            pkt['src'],\n\
      \                            pkt['seq'],\n                            self.PKT_ACK\n\
      \                        )\n                        print(f\"[Node {self.node_id}]\
      \ RX: Sending ACK for seq={pkt['seq']}\")\n                        self.transmit_packet(ack_packet)\n\
      \                        self.stats['acks_sent'] += 1\n                    \
      \    \n                        # Forward to application if not duplicate\n \
      \                       if not is_duplicate:\n                            self.forward_to_app(pkt['src'],\
      \ pkt['payload'])\n                        \n                    elif pkt['type']\
      \ == self.PKT_ACK:\n                        print(f\"[Node {self.node_id}] RX:\
      \ ACK packet from node {pkt['src']}, seq={pkt['seq']}\")\n                 \
      \       # Process ACK\n                        ack_key = f\"{pkt['src']}_{pkt['seq']}\"\
      \n                        self.ack_queue.put({'key': ack_key})\n           \
      \             \n            except Exception as e:\n                print(f\"\
      [Node {self.node_id}] RX handler error: {e}\")\n    \n    def transmit_packet(self,\
      \ packet):\n        \"\"\"Send packet to physical layer\"\"\"\n        try:\n\
      \            # Convert to PDU format\n            vec = pmt.init_u8vector(len(packet),\
      \ list(packet))\n            pdu = pmt.cons(pmt.PMT_NIL, vec)\n            \n\
      \            # Send to modulator\n            self.message_port_pub(pmt.intern('pdu_out'),\
      \ pdu)\n            \n        except Exception as e:\n            print(f\"\
      [Node {self.node_id}] Error transmitting packet: {e}\")\n    \n    def forward_to_app(self,\
      \ src_id, data):\n        \"\"\"Forward received data to application/GUI\"\"\
      \"\n        try:\n            # Decode message\n            message = data.decode('utf-8',\
      \ errors='ignore')\n            \n            # Create formatted output string\n\
      \            output = f\"[From Node {src_id}]: {message}\"\n            \n \
      \           # Send as simple string message\n            msg = pmt.intern(output)\n\
      \            self.message_port_pub(pmt.intern('msg_out'), msg)\n           \
      \ \n            # Also send as dictionary for more complex processing\n    \
      \        meta = pmt.make_dict()\n            meta = pmt.dict_add(meta, pmt.intern(\"\
      src\"), pmt.from_long(src_id))\n            meta = pmt.dict_add(meta, pmt.intern(\"\
      data\"), pmt.intern(message))\n            \n            print(f\"[Node {self.node_id}]\
      \ Message delivered: {output}\")\n            \n        except Exception as\
      \ e:\n            print(f\"[Node {self.node_id}] Error forwarding to app: {e}\"\
      )\n    \n    def work(self, input_items, output_items):\n        \"\"\"Main\
      \ work function (not used for message passing blocks)\"\"\"\n        return\
      \ 0\n    \n    def stop(self):\n        \"\"\"Clean shutdown\"\"\"\n       \
      \ print(f\"\\n[Node {self.node_id}] Statistics:\")\n        print(f\"  Packets\
      \ sent: {self.stats['packets_sent']}\")\n        print(f\"  Packets received:\
      \ {self.stats['packets_received']}\")\n        print(f\"  ACKs sent: {self.stats['acks_sent']}\"\
      )\n        print(f\"  ACKs received: {self.stats['acks_received']}\")\n    \
      \    print(f\"  Retransmissions: {self.stats['retransmissions']}\")\n      \
      \  print(f\"  CRC errors: {self.stats['crc_errors']}\")\n        \n        self.running\
      \ = False\n        if self.tx_thread.is_alive():\n            self.tx_thread.join()\n\
      \        if self.rx_thread.is_alive():\n            self.rx_thread.join()\n\
      \        return True\n"
    affinity: ''
    alias: ''
    aloha_prob: '0.6'
    comment: User 2
    max_retries: '3'
    maxoutbuf: '0'
    minoutbuf: '0'
    node_id: '2'
    timeout: '0.2'
  states:
    _io_cache: ('Mesh Packet Comm', 'blk', [('node_id', '1'), ('aloha_prob', '0.3'),
      ('timeout', '1.0'), ('max_retries', '3')], [('pdu_in', 'message', 1), ('msg_in',
      'message', 1)], [('feedback', 'message', 1), ('pdu_out', 'message', 1), ('msg_out',
      'message', 1)], '\n    Mesh Network Packet Communication Block\n    Handles
      packet transmission/reception with Stop-and-Wait ARQ\n    ', ['aloha_prob',
      'max_retries', 'node_id', 'timeout'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [472, 1316.0]
    rotation: 0
    state: enabled
- name: epy_block_0_1
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom gnuradio\
      \ import gr\nfrom PyQt5 import QtWidgets, QtCore, QtGui\nimport sys\nimport\
      \ pmt\nfrom datetime import datetime\n\nclass WallpaperScrollArea(QtWidgets.QScrollArea):\n\
      \    def __init__(self, bg_image=\"\", parent=None):\n        super().__init__(parent)\n\
      \        self.setWidgetResizable(True)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n\
      \        self.bg_pixmap = QtGui.QPixmap(bg_image) if bg_image else None\n\n\
      \    def paintEvent(self, event):\n        if self.bg_pixmap:\n            painter\
      \ = QtGui.QPainter(self.viewport())\n            painter.drawPixmap(self.viewport().rect(),\
      \ self.bg_pixmap)\n        super().paintEvent(event)\n\n\nclass _GuiPoster(QtCore.QObject):\n\
      \    \"\"\"Helper QObject to post strings into the Qt thread safely.\"\"\"\n\
      \    sig = QtCore.pyqtSignal(str)  # emits text payload\n\n    def __init__(self):\n\
      \        super().__init__()\n\n\nclass messenger_gui(gr.basic_block):\n    \"\
      \"\"\n    WhatsApp-style Messenger GUI (GNU Radio embedded block).\n    - Outgoing\
      \ messages: published on message port \"out\" with address prepended as \"addr:body\"\
      \n    - Feedback port \"feedback\": updates delivery timestamp / failed status\n\
      \    - Incoming messages: received on port \"in_msg\" (same format \"addr:body\"\
      ) and displayed\n      on the left in a different color.\n    \"\"\"\n\n   \
      \ def __init__(self, bg_image=\"\"):\n        gr.basic_block.__init__(\n   \
      \         self,\n            name=\"Messenger GUI\",\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n\n        # Message ports\n        self.message_port_register_out(pmt.intern(\"\
      out\"))    # outgoing messages\n        self.message_port_register_in(pmt.intern(\"\
      feedback\"))# delivery feedback\n        self.message_port_register_in(pmt.intern(\"\
      in_msg\"))  # incoming messages from remote/devices\n\n        # Bind handlers\n\
      \        self.set_msg_handler(pmt.intern(\"feedback\"), self._process_feedback)\n\
      \        self.set_msg_handler(pmt.intern(\"in_msg\"), self._receive_message)\n\
      \n        # Poster used to safely move messages to GUI thread\n        self._poster\
      \ = _GuiPoster()\n        self._poster.sig.connect(self._display_incoming) \
      \ # connect to GUI-thread handler\n\n        # Qt Application\n        self.app\
      \ = QtWidgets.QApplication.instance()\n        if self.app is None:\n      \
      \      self.app = QtWidgets.QApplication(sys.argv)\n\n        # Main window\n\
      \        self.qt_widget = QtWidgets.QWidget()\n        self.qt_widget.setWindowTitle(\"\
      Messenger GUI\")\n        self.qt_widget.resize(640, 560)\n\n        main_layout\
      \ = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(8, 8, 8,\
      \ 8)\n        main_layout.setSpacing(6)\n        self.qt_widget.setLayout(main_layout)\n\
      \n        # Address selection bar\n        addr_layout = QtWidgets.QHBoxLayout()\n\
      \        addr_label = QtWidgets.QLabel(\"To:\")\n        addr_label.setStyleSheet(\"\
      font-size: 18px; font-weight: bold;\")\n        addr_layout.addWidget(addr_label)\n\
      \n        self.addr_box = QtWidgets.QComboBox()\n        self.addr_box.addItems([str(i)\
      \ for i in range(1, 11)])  # 1..10 default\n        self.addr_box.setFixedWidth(100)\n\
      \        self.addr_box.setStyleSheet(\"font-size: 16px; padding: 4px;\")\n \
      \       addr_layout.addWidget(self.addr_box)\n        addr_layout.addStretch()\n\
      \n        main_layout.addLayout(addr_layout)\n\n        # Scroll area with background\n\
      \        self.scroll_area = WallpaperScrollArea(bg_image=bg_image)\n       \
      \ self.scroll_area.setStyleSheet(\"border: none;\")\n        self.scroll_area.setWidgetResizable(True)\n\
      \        main_layout.addWidget(self.scroll_area, stretch=1)\n\n        # Chat\
      \ container (vertical list of message widgets)\n        self.chat_container\
      \ = QtWidgets.QWidget()\n        self.chat_layout = QtWidgets.QVBoxLayout()\n\
      \        self.chat_layout.setAlignment(QtCore.Qt.AlignTop)\n        self.chat_layout.setSpacing(10)\n\
      \        self.chat_container.setLayout(self.chat_layout)\n        self.chat_container.setStyleSheet(\"\
      background: transparent;\")\n        self.scroll_area.setWidget(self.chat_container)\n\
      \n        # Input area (text entry + send)\n        input_layout = QtWidgets.QHBoxLayout()\n\
      \        self.input_box = QtWidgets.QLineEdit()\n        self.input_box.setPlaceholderText(\"\
      Type a message...\")\n        self.input_box.setMinimumHeight(40)\n        self.input_box.setStyleSheet(\"\
      \"\"\n            QLineEdit {\n                border-radius: 12px;\n      \
      \          padding: 8px;\n                background-color: rgba(255,255,255,0.95);\n\
      \                font-size: 16px;\n            }\n        \"\"\")\n        self.send_button\
      \ = QtWidgets.QPushButton(\"Send\")\n        self.send_button.setMinimumHeight(40)\n\
      \        self.send_button.setStyleSheet(\"\"\"\n            QPushButton {\n\
      \                background-color: #4CAF50;\n                color: white;\n\
      \                border-radius: 10px;\n                padding: 8px 16px;\n\
      \                font-weight: bold;\n                font-size: 16px;\n    \
      \        }\n            QPushButton:hover { background-color: #45a049; }\n \
      \       \"\"\")\n        input_layout.addWidget(self.input_box, stretch=1)\n\
      \        input_layout.addWidget(self.send_button, stretch=0)\n        main_layout.addLayout(input_layout)\n\
      \n        # Connect GUI signals\n        self.send_button.clicked.connect(self.send_message)\n\
      \        self.input_box.returnPressed.connect(self.send_message)\n\n       \
      \ # Track last sent message timestamp widget (simple approach)\n        # If\
      \ you want per-message tracking, change to a list/map of widgets per message\
      \ id.\n        self._last_message_timestamp = None\n\n        # show window\n\
      \        self.qt_widget.show()\n\n    def send_message(self):\n        \"\"\"\
      Called from GUI thread when user presses Send or Enter.\"\"\"\n        text\
      \ = self.input_box.text().strip()\n        if not text:\n            return\n\
      \n        addr = self.addr_box.currentText().strip()\n        full_msg = f\"\
      {addr}:{text}\"\n\n        # Publish as PMT symbol/string on 'out' port\n  \
      \      try:\n            self.message_port_pub(pmt.intern(\"out\"), pmt.intern(full_msg))\n\
      \        except Exception:\n            # fallback to generic intern\n     \
      \       self.message_port_pub(pmt.intern(\"out\"), pmt.intern(full_msg))\n\n\
      \        # Build outgoing bubble (right side)\n        container = QtWidgets.QWidget()\n\
      \        vbox = QtWidgets.QVBoxLayout()\n        vbox.setContentsMargins(0,\
      \ 0, 0, 0)\n        vbox.setSpacing(4)\n\n        # Scrollable area for long\
      \ messages\n        scroll = QtWidgets.QScrollArea()\n        scroll.setWidgetResizable(True)\n\
      \        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\
      \        scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       scroll.setFrameShape(QtWidgets.QFrame.NoFrame)\n        scroll.setStyleSheet(\"\
      background: transparent; border: none;\")\n\n        bubble = QtWidgets.QLabel(text)\
      \  # show only body (user-friendly)\n        bubble.setWordWrap(False)\n   \
      \     bubble.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)\n    \
      \    bubble.setStyleSheet(\"\"\"\n            QLabel {\n                background-color:\
      \ qlineargradient(x1:0,y1:0,x2:1,y2:1, stop:0 #4CAF50, stop:1 #66BB6A);\n  \
      \              color: white;\n                border-radius: 12px;\n       \
      \         padding: 8px 12px;\n                font-size: 14px;\n           \
      \ }\n        \"\"\")\n        # shadow\n        effect = QtWidgets.QGraphicsDropShadowEffect()\n\
      \        effect.setBlurRadius(6)\n        effect.setXOffset(2)\n        effect.setYOffset(2)\n\
      \        effect.setColor(QtGui.QColor(0, 0, 0, 80))\n        bubble.setGraphicsEffect(effect)\n\
      \n        scroll.setWidget(bubble)\n        scroll.setMinimumWidth(160)\n  \
      \      scroll.setMaximumWidth(520)\n\n        # Timestamp pill (initially 'Sending...')\n\
      \        timestamp = QtWidgets.QLabel(\"Sending...\")\n        timestamp.setStyleSheet(\"\
      \"\"\n            QLabel {\n                background-color: #2196F3;\n   \
      \             color: white;\n                font-size: 11px;\n            \
      \    border-radius: 8px;\n                padding: 2px 6px;\n            }\n\
      \        \"\"\")\n        timestamp.setAlignment(QtCore.Qt.AlignRight)\n   \
      \     timestamp.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n\
      \n        vbox.addWidget(scroll, alignment=QtCore.Qt.AlignRight)\n        vbox.addWidget(timestamp,\
      \ alignment=QtCore.Qt.AlignRight)\n        container.setLayout(vbox)\n     \
      \   container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)\n\
      \n        # Add to chat layout (right aligned)\n        self.chat_layout.addWidget(container,\
      \ alignment=QtCore.Qt.AlignRight)\n\n        # Force layout update and scroll\
      \ to bottom\n        bubble.adjustSize()\n        scroll.adjustSize()\n    \
      \    container.adjustSize()\n        self.chat_container.adjustSize()\n    \
      \    QtWidgets.QApplication.processEvents()\n        QtCore.QTimer.singleShot(20,\
      \ lambda: self.scroll_area.verticalScrollBar().setValue(\n            self.scroll_area.verticalScrollBar().maximum()\n\
      \        ))\n\n        # Clear input and store timestamp widget for feedback\
      \ updates\n        self.input_box.clear()\n        self._last_message_timestamp\
      \ = timestamp\n\n    def _process_feedback(self, msg_pmt):\n        \"\"\"\n\
      \        Handler for 'feedback' port. Expected feedback values:\n          -\
      \ \"TRUE\" => show delivery time\n          - \"FALSE\" => show 'Failed'\n \
      \       \"\"\"\n        try:\n            if pmt.is_symbol(msg_pmt) or pmt.is_string(msg_pmt):\n\
      \                fb = pmt.symbol_to_string(msg_pmt)\n            else:\n   \
      \             py = pmt.to_python(msg_pmt)\n                fb = str(py)\n  \
      \      except Exception:\n            fb = \"<unreadable feedback>\"\n\n   \
      \     print(fb)\n        # Update last timestamp widget if available (simple\
      \ single-last approach)\n        if self._last_message_timestamp:\n        \
      \    if fb == \"TRUE\":\n                self._last_message_timestamp.setText(datetime.now().strftime(\"\
      %H:%M:%S\"))\n                self._last_message_timestamp.setStyleSheet(\"\"\
      \"\n                    QLabel {\n                        background-color:\
      \ #2196F3;\n                        color: white;\n                        font-size:\
      \ 11px;\n                        border-radius: 8px;\n                     \
      \   padding: 2px 6px;\n                    }\n                \"\"\")\n    \
      \        elif fb == \"FALSE\":\n                self._last_message_timestamp.setText(\"\
      Failed\")\n                self._last_message_timestamp.setStyleSheet(\"\"\"\
      \n                    QLabel {\n                        background-color: #F44336;\n\
      \                        color: white;\n                        font-size: 11px;\n\
      \                        border-radius: 8px;\n                        padding:\
      \ 2px 6px;\n                    }\n                \"\"\")\n\n    def _receive_message(self,\
      \ msg_pmt):\n        \"\"\"\n        Handler for 'in_msg' port. Extracts string\
      \ and posts it to GUI thread\n        via _poster.sig so _display_incoming runs\
      \ in Qt thread.\n        \"\"\"\n        try:\n            if pmt.is_symbol(msg_pmt)\
      \ or pmt.is_string(msg_pmt):\n                s = pmt.symbol_to_string(msg_pmt)\n\
      \            else:\n                py = pmt.to_python(msg_pmt)\n          \
      \      s = str(py)\n        except Exception:\n            s = \"<unreadable\
      \ message>\"\n\n        # Post to GUI-thread handler\n        try:\n       \
      \     self._poster.sig.emit(s)\n        except Exception:\n            # If\
      \ signal emit fails for any reason, try direct call in case we're already in\
      \ Qt thread\n            try:\n                self._display_incoming(s)\n \
      \           except Exception:\n                print(\"[messenger_gui] failed\
      \ to deliver incoming message to GUI:\", s)\n\n    def _display_incoming(self,\
      \ full_msg):\n        \"\"\"\n        Build incoming bubble (left aligned).\
      \ full_msg expected in \"addr:body\" format.\n        \"\"\"\n        # try\
      \ to split \"addr:body\"\n        if \":\" in full_msg:\n            addr, body\
      \ = full_msg.split(\":\", 1)\n            display_text = f\"{body}\"\n     \
      \       header_text = f\"{addr}\"\n        else:\n            display_text =\
      \ full_msg\n            header_text = \"\"\n\n        container = QtWidgets.QWidget()\n\
      \        vbox = QtWidgets.QVBoxLayout()\n        vbox.setContentsMargins(0,\
      \ 0, 0, 0)\n        vbox.setSpacing(4)\n\n        scroll = QtWidgets.QScrollArea()\n\
      \        scroll.setWidgetResizable(True)\n        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\
      \        scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       scroll.setFrameShape(QtWidgets.QFrame.NoFrame)\n        scroll.setStyleSheet(\"\
      background: transparent; border: none;\")\n\n        bubble = QtWidgets.QLabel(display_text)\n\
      \        bubble.setWordWrap(False)\n        bubble.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)\n\
      \        bubble.setStyleSheet(\"\"\"\n            QLabel {\n               \
      \ background-color: qlineargradient(x1:0,y1:0,x2:1,y2:1, stop:0 #E1F5FE, stop:1\
      \ #B3E5FC);\n                color: #0B2545;\n                border-radius:\
      \ 12px;\n                padding: 8px 12px;\n                font-size: 14px;\n\
      \            }\n        \"\"\")\n\n        # small header with sender address\
      \ (optional)\n        if header_text:\n            header = QtWidgets.QLabel(header_text)\n\
      \            header.setStyleSheet(\"font-size: 11px; color: #1565C0;\")\n  \
      \          header.setAlignment(QtCore.Qt.AlignLeft)\n            vbox.addWidget(header,\
      \ alignment=QtCore.Qt.AlignLeft)\n\n        scroll.setWidget(bubble)\n     \
      \   scroll.setMinimumWidth(160)\n        scroll.setMaximumWidth(520)\n\n   \
      \     vbox.addWidget(scroll, alignment=QtCore.Qt.AlignLeft)\n\n        # incoming\
      \ messages do not have delivery timestamp pill (feedback relates to outgoing)\n\
      \        container.setLayout(vbox)\n        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding,\
      \ QtWidgets.QSizePolicy.Fixed)\n\n        self.chat_layout.addWidget(container,\
      \ alignment=QtCore.Qt.AlignLeft)\n\n        # Update layout and scroll to bottom\n\
      \        bubble.adjustSize()\n        scroll.adjustSize()\n        container.adjustSize()\n\
      \        self.chat_container.adjustSize()\n        QtWidgets.QApplication.processEvents()\n\
      \        QtCore.QTimer.singleShot(20, lambda: self.scroll_area.verticalScrollBar().setValue(\n\
      \            self.scroll_area.verticalScrollBar().maximum()\n        ))\n"
    affinity: ''
    alias: ''
    bg_image: r"C:\Users\Oshan\Desktop\message.jpg"
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: '(''Messenger GUI'', ''messenger_gui'', [(''bg_image'', "''''")], [(''in_msg'',
      ''message'', 1), (''feedback'', ''message'', 1)], [(''out'', ''message'', 1)],
      ''\n    WhatsApp-style Messenger GUI (GNU Radio embedded block).\n    - Outgoing
      messages: published on message port "out" with address prepended as "addr:body"\n    -
      Feedback port "feedback": updates delivery timestamp / failed status\n    -
      Incoming messages: received on port "in_msg" (same format "addr:body") and displayed\n      on
      the left in a different color.\n    '', [])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 920.0]
    rotation: 180
    state: enabled
- name: epy_block_0_1_0
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom gnuradio\
      \ import gr\nfrom PyQt5 import QtWidgets, QtCore, QtGui\nimport sys\nimport\
      \ pmt\nimport time\nfrom datetime import datetime  # for timestamps\n\nclass\
      \ WallpaperScrollArea(QtWidgets.QScrollArea):\n    def __init__(self, bg_image=\"\
      \", parent=None):\n        super().__init__(parent)\n        self.setWidgetResizable(True)\n\
      \        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       self.bg_pixmap = QtGui.QPixmap(bg_image) if bg_image else None\n\n \
      \   def paintEvent(self, event):\n        if self.bg_pixmap:\n            painter\
      \ = QtGui.QPainter(self.viewport())\n            painter.drawPixmap(self.viewport().rect(),\
      \ self.bg_pixmap)\n        super().paintEvent(event)\n\n\nclass messenger_gui(gr.basic_block):\n\
      \    \"\"\"\n    WhatsApp-style Messenger GUI with dynamic bubble resizing,\n\
      \    horizontal scroll for long messages, timestamp update on delivery,\n  \
      \  and failure indication if retry limit is exceeded.\n    \"\"\"\n\n    def\
      \ __init__(self, bg_image=\"\"):\n        gr.basic_block.__init__(\n       \
      \     self,\n            name=\"Messenger GUI\",\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n\n        # Message ports\n        self.message_port_register_out(pmt.intern(\"\
      out\"))\n        self.message_port_register_in(pmt.intern(\"feedback\"))\n \
      \       self.set_msg_handler(pmt.intern(\"feedback\"), self._process_feedback)\n\
      \n        # Qt Application\n        self.app = QtWidgets.QApplication.instance()\n\
      \        if self.app is None:\n            self.app = QtWidgets.QApplication(sys.argv)\n\
      \n        self.qt_widget = QtWidgets.QWidget()\n        self.qt_widget.setWindowTitle(\"\
      Messenger GUI\")\n        self.qt_widget.resize(600, 500)\n\n        main_layout\
      \ = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(0, 0, 0,\
      \ 0)\n        main_layout.setSpacing(0)\n        self.qt_widget.setLayout(main_layout)\n\
      \n        # Scroll area with background\n        self.scroll_area = WallpaperScrollArea(bg_image=bg_image)\n\
      \        self.scroll_area.setStyleSheet(\"border: none;\")\n        self.scroll_area.setWidgetResizable(True)\n\
      \        main_layout.addWidget(self.scroll_area, stretch=1)\n\n        # Chat\
      \ container\n        self.chat_container = QtWidgets.QWidget()\n        self.chat_layout\
      \ = QtWidgets.QVBoxLayout()\n        self.chat_layout.setAlignment(QtCore.Qt.AlignTop)\n\
      \        self.chat_layout.setSpacing(10)\n        self.chat_container.setLayout(self.chat_layout)\n\
      \        self.chat_container.setStyleSheet(\"background: transparent;\")\n \
      \       self.scroll_area.setWidget(self.chat_container)\n\n        # Input area\n\
      \        input_layout = QtWidgets.QHBoxLayout()\n        self.input_box = QtWidgets.QLineEdit()\n\
      \        self.input_box.setPlaceholderText(\"Type a message...\")\n        self.input_box.setStyleSheet(\"\
      \"\"\n            QLineEdit {\n                border-radius: 15px;\n      \
      \          padding: 12px;\n                background-color: rgba(255,255,255,230);\n\
      \                font-size: 32px;\n            }\n        \"\"\")\n        self.send_button\
      \ = QtWidgets.QPushButton(\"Send\")\n        self.send_button.setStyleSheet(\"\
      \"\"\n            QPushButton {\n                background-color: #4CAF50;\n\
      \                color: white;\n                border-radius: 15px;\n     \
      \           padding: 12px 24px;\n                font-weight: bold;\n      \
      \          font-size: 32px;\n            }\n            QPushButton:hover {\n\
      \                background-color: #45a049;\n            }\n        \"\"\")\n\
      \        input_layout.addWidget(self.input_box)\n        input_layout.addWidget(self.send_button)\n\
      \        main_layout.addLayout(input_layout)\n\n        # Connect signals\n\
      \        self.send_button.clicked.connect(self.send_message)\n        self.input_box.returnPressed.connect(self.send_message)\n\
      \n        self._last_message_timestamp = None\n        self.qt_widget.show()\n\
      \n    def send_message(self):\n        text = self.input_box.text().strip()\n\
      \        if not text:\n            return\n\n        # Send message via GNU\
      \ Radio port\n        self.message_port_pub(pmt.intern(\"out\"), pmt.string_to_symbol(text))\n\
      \n        # Scrollable bubble container\n        scroll = QtWidgets.QScrollArea()\n\
      \        scroll.setWidgetResizable(True)\n        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\
      \        scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       scroll.setStyleSheet(\"border: none; background: transparent;\")\n\n\
      \        # Message bubble\n        bubble = QtWidgets.QLabel(text)\n       \
      \ bubble.setWordWrap(False)  # Disable wrapping\n        bubble.setStyleSheet(\"\
      \"\"\n            QLabel {\n                background-color: qlineargradient(x1:0,\
      \ y1:0, x2:1, y2:1,\n                    stop:0 #4CAF50, stop:1 #66BB6A);\n\
      \                color: white;\n                border-radius: 15px;\n     \
      \           padding: 10px 15px;\n                font-size: 32px;\n        \
      \    }\n        \"\"\")\n\n        # Shadow effect\n        effect = QtWidgets.QGraphicsDropShadowEffect()\n\
      \        effect.setBlurRadius(6)\n        effect.setXOffset(2)\n        effect.setYOffset(2)\n\
      \        effect.setColor(QtGui.QColor(0, 0, 0, 100))\n        bubble.setGraphicsEffect(effect)\n\
      \n        scroll.setWidget(bubble)\n        scroll.setMinimumWidth(200)\n  \
      \      scroll.setMaximumWidth(550)  # Max visible width of bubble\n        bubble.adjustSize()\n\
      \        scroll.adjustSize()\n\n        # Timestamp label as small blue pill\
      \ initially\n        timestamp = QtWidgets.QLabel(\"Sending...\")\n        timestamp.setStyleSheet(\"\
      \"\"\n            QLabel {\n                background-color: #2196F3;  /* blue\
      \ background */\n                color: white;\n                font-size: 18px;\n\
      \                border-radius: 8px;\n                padding: 2px 6px;\n  \
      \          }\n        \"\"\")\n        timestamp.setAlignment(QtCore.Qt.AlignRight)\n\
      \        timestamp.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n\
      \n        # Container for bubble + timestamp\n        container = QtWidgets.QWidget()\n\
      \        vbox = QtWidgets.QVBoxLayout()\n        vbox.setContentsMargins(0,\
      \ 0, 0, 0)\n        vbox.setSpacing(2)\n        vbox.addWidget(scroll)\n   \
      \     vbox.addWidget(timestamp, alignment=QtCore.Qt.AlignRight)\n        container.setLayout(vbox)\n\
      \        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)\n\
      \n        # Add to chat layout\n        self.chat_layout.addWidget(container,\
      \ alignment=QtCore.Qt.AlignRight)\n\n        # Force proper size recalculation\n\
      \        bubble.adjustSize()\n        scroll.adjustSize()\n        container.adjustSize()\n\
      \        self.chat_container.adjustSize()\n        QtWidgets.QApplication.processEvents()\
      \  # Force layout update\n\n        # Scroll to bottom\n        QtCore.QTimer.singleShot(50,\
      \ lambda: self.scroll_area.verticalScrollBar().setValue(\n            self.scroll_area.verticalScrollBar().maximum()\n\
      \        ))\n\n        self.input_box.clear()\n        self._last_message_timestamp\
      \ = timestamp\n\n    def _process_feedback(self, msg):\n        try:\n     \
      \       if pmt.is_symbol(msg):\n                feedback = pmt.symbol_to_string(msg)\n\
      \n                if feedback == \"END_ACK_RECEIVED\" and self._last_message_timestamp:\n\
      \                    # Successful delivery: show current time in blue pill\n\
      \                    self._last_message_timestamp.setText(datetime.now().strftime(\"\
      %H:%M\"))\n                    self._last_message_timestamp.setStyleSheet(\"\
      \"\"\n                        QLabel {\n                            background-color:\
      \ #2196F3;  /* blue background */\n                            color: white;\n\
      \                            font-size: 18px;\n                            border-radius:\
      \ 8px;\n                            padding: 2px 6px;\n                    \
      \    }\n                    \"\"\")\n\n                elif feedback == \"RETRY_LIMIT_EXCEEDED\"\
      \ and self._last_message_timestamp:\n                    # Failed delivery:\
      \ red pill\n                    self._last_message_timestamp.setText(\"Failed\"\
      )\n                    self._last_message_timestamp.setStyleSheet(\"\"\"\n \
      \                       QLabel {\n                            background-color:\
      \ #F44336;  /* red background */\n                            color: white;\n\
      \                            font-size: 18px;\n                            border-radius:\
      \ 8px;\n                            padding: 2px 6px;\n                    \
      \    }\n                    \"\"\")\n\n        except Exception as e:\n    \
      \        print(f\"[messenger_gui] Error processing feedback: {e}\")\n\n"
    affinity: ''
    alias: User 1 GUI
    bg_image: '''/home/vboxuser/Downloads/tx.jpg'''
    comment: User 1 GUI
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Messenger GUI', 'messenger_gui', [('bg_image', "''")], [('feedback',
      'message', 1)], [('out', 'message', 1)], '\n    WhatsApp-style Messenger GUI
      with dynamic bubble resizing,\n    horizontal scroll for long messages, timestamp
      update on delivery,\n    and failure indication if retry limit is exceeded.\n    ',
      [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [120, 776.0]
    rotation: 0
    state: disabled
- name: epy_block_0_1_0_0
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom gnuradio\
      \ import gr\nfrom PyQt5 import QtWidgets, QtCore, QtGui\nimport sys\nimport\
      \ pmt\nimport time\nfrom datetime import datetime  # for timestamps\n\nclass\
      \ WallpaperScrollArea(QtWidgets.QScrollArea):\n    def __init__(self, bg_image=\"\
      \", parent=None):\n        super().__init__(parent)\n        self.setWidgetResizable(True)\n\
      \        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       self.bg_pixmap = QtGui.QPixmap(bg_image) if bg_image else None\n\n \
      \   def paintEvent(self, event):\n        if self.bg_pixmap:\n            painter\
      \ = QtGui.QPainter(self.viewport())\n            painter.drawPixmap(self.viewport().rect(),\
      \ self.bg_pixmap)\n        super().paintEvent(event)\n\n\nclass messenger_gui(gr.basic_block):\n\
      \    \"\"\"\n    WhatsApp-style Messenger GUI with dynamic bubble resizing,\n\
      \    horizontal scroll for long messages, timestamp update on delivery,\n  \
      \  and failure indication if retry limit is exceeded.\n    \"\"\"\n\n    def\
      \ __init__(self, bg_image=\"\"):\n        gr.basic_block.__init__(\n       \
      \     self,\n            name=\"Messenger GUI\",\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n\n        # Message ports\n        self.message_port_register_out(pmt.intern(\"\
      out\"))\n        self.message_port_register_in(pmt.intern(\"feedback\"))\n \
      \       self.set_msg_handler(pmt.intern(\"feedback\"), self._process_feedback)\n\
      \n        # Qt Application\n        self.app = QtWidgets.QApplication.instance()\n\
      \        if self.app is None:\n            self.app = QtWidgets.QApplication(sys.argv)\n\
      \n        self.qt_widget = QtWidgets.QWidget()\n        self.qt_widget.setWindowTitle(\"\
      Messenger GUI\")\n        self.qt_widget.resize(600, 500)\n\n        main_layout\
      \ = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(0, 0, 0,\
      \ 0)\n        main_layout.setSpacing(0)\n        self.qt_widget.setLayout(main_layout)\n\
      \n        # Scroll area with background\n        self.scroll_area = WallpaperScrollArea(bg_image=bg_image)\n\
      \        self.scroll_area.setStyleSheet(\"border: none;\")\n        self.scroll_area.setWidgetResizable(True)\n\
      \        main_layout.addWidget(self.scroll_area, stretch=1)\n\n        # Chat\
      \ container\n        self.chat_container = QtWidgets.QWidget()\n        self.chat_layout\
      \ = QtWidgets.QVBoxLayout()\n        self.chat_layout.setAlignment(QtCore.Qt.AlignTop)\n\
      \        self.chat_layout.setSpacing(10)\n        self.chat_container.setLayout(self.chat_layout)\n\
      \        self.chat_container.setStyleSheet(\"background: transparent;\")\n \
      \       self.scroll_area.setWidget(self.chat_container)\n\n        # Input area\n\
      \        input_layout = QtWidgets.QHBoxLayout()\n        self.input_box = QtWidgets.QLineEdit()\n\
      \        self.input_box.setPlaceholderText(\"Type a message...\")\n        self.input_box.setStyleSheet(\"\
      \"\"\n            QLineEdit {\n                border-radius: 15px;\n      \
      \          padding: 12px;\n                background-color: rgba(255,255,255,230);\n\
      \                font-size: 32px;\n            }\n        \"\"\")\n        self.send_button\
      \ = QtWidgets.QPushButton(\"Send\")\n        self.send_button.setStyleSheet(\"\
      \"\"\n            QPushButton {\n                background-color: #4CAF50;\n\
      \                color: white;\n                border-radius: 15px;\n     \
      \           padding: 12px 24px;\n                font-weight: bold;\n      \
      \          font-size: 32px;\n            }\n            QPushButton:hover {\n\
      \                background-color: #45a049;\n            }\n        \"\"\")\n\
      \        input_layout.addWidget(self.input_box)\n        input_layout.addWidget(self.send_button)\n\
      \        main_layout.addLayout(input_layout)\n\n        # Connect signals\n\
      \        self.send_button.clicked.connect(self.send_message)\n        self.input_box.returnPressed.connect(self.send_message)\n\
      \n        self._last_message_timestamp = None\n        self.qt_widget.show()\n\
      \n    def send_message(self):\n        text = self.input_box.text().strip()\n\
      \        if not text:\n            return\n\n        # Send message via GNU\
      \ Radio port\n        self.message_port_pub(pmt.intern(\"out\"), pmt.string_to_symbol(text))\n\
      \n        # Scrollable bubble container\n        scroll = QtWidgets.QScrollArea()\n\
      \        scroll.setWidgetResizable(True)\n        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\
      \        scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       scroll.setStyleSheet(\"border: none; background: transparent;\")\n\n\
      \        # Message bubble\n        bubble = QtWidgets.QLabel(text)\n       \
      \ bubble.setWordWrap(False)  # Disable wrapping\n        bubble.setStyleSheet(\"\
      \"\"\n            QLabel {\n                background-color: qlineargradient(x1:0,\
      \ y1:0, x2:1, y2:1,\n                    stop:0 #4CAF50, stop:1 #66BB6A);\n\
      \                color: white;\n                border-radius: 15px;\n     \
      \           padding: 10px 15px;\n                font-size: 32px;\n        \
      \    }\n        \"\"\")\n\n        # Shadow effect\n        effect = QtWidgets.QGraphicsDropShadowEffect()\n\
      \        effect.setBlurRadius(6)\n        effect.setXOffset(2)\n        effect.setYOffset(2)\n\
      \        effect.setColor(QtGui.QColor(0, 0, 0, 100))\n        bubble.setGraphicsEffect(effect)\n\
      \n        scroll.setWidget(bubble)\n        scroll.setMinimumWidth(200)\n  \
      \      scroll.setMaximumWidth(550)  # Max visible width of bubble\n        bubble.adjustSize()\n\
      \        scroll.adjustSize()\n\n        # Timestamp label as small blue pill\
      \ initially\n        timestamp = QtWidgets.QLabel(\"Sending...\")\n        timestamp.setStyleSheet(\"\
      \"\"\n            QLabel {\n                background-color: #2196F3;  /* blue\
      \ background */\n                color: white;\n                font-size: 18px;\n\
      \                border-radius: 8px;\n                padding: 2px 6px;\n  \
      \          }\n        \"\"\")\n        timestamp.setAlignment(QtCore.Qt.AlignRight)\n\
      \        timestamp.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n\
      \n        # Container for bubble + timestamp\n        container = QtWidgets.QWidget()\n\
      \        vbox = QtWidgets.QVBoxLayout()\n        vbox.setContentsMargins(0,\
      \ 0, 0, 0)\n        vbox.setSpacing(2)\n        vbox.addWidget(scroll)\n   \
      \     vbox.addWidget(timestamp, alignment=QtCore.Qt.AlignRight)\n        container.setLayout(vbox)\n\
      \        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)\n\
      \n        # Add to chat layout\n        self.chat_layout.addWidget(container,\
      \ alignment=QtCore.Qt.AlignRight)\n\n        # Force proper size recalculation\n\
      \        bubble.adjustSize()\n        scroll.adjustSize()\n        container.adjustSize()\n\
      \        self.chat_container.adjustSize()\n        QtWidgets.QApplication.processEvents()\
      \  # Force layout update\n\n        # Scroll to bottom\n        QtCore.QTimer.singleShot(50,\
      \ lambda: self.scroll_area.verticalScrollBar().setValue(\n            self.scroll_area.verticalScrollBar().maximum()\n\
      \        ))\n\n        self.input_box.clear()\n        self._last_message_timestamp\
      \ = timestamp\n\n    def _process_feedback(self, msg):\n        try:\n     \
      \       if pmt.is_symbol(msg):\n                feedback = pmt.symbol_to_string(msg)\n\
      \n                if feedback == \"END_ACK_RECEIVED\" and self._last_message_timestamp:\n\
      \                    # Successful delivery: show current time in blue pill\n\
      \                    self._last_message_timestamp.setText(datetime.now().strftime(\"\
      %H:%M\"))\n                    self._last_message_timestamp.setStyleSheet(\"\
      \"\"\n                        QLabel {\n                            background-color:\
      \ #2196F3;  /* blue background */\n                            color: white;\n\
      \                            font-size: 18px;\n                            border-radius:\
      \ 8px;\n                            padding: 2px 6px;\n                    \
      \    }\n                    \"\"\")\n\n                elif feedback == \"RETRY_LIMIT_EXCEEDED\"\
      \ and self._last_message_timestamp:\n                    # Failed delivery:\
      \ red pill\n                    self._last_message_timestamp.setText(\"Failed\"\
      )\n                    self._last_message_timestamp.setStyleSheet(\"\"\"\n \
      \                       QLabel {\n                            background-color:\
      \ #F44336;  /* red background */\n                            color: white;\n\
      \                            font-size: 18px;\n                            border-radius:\
      \ 8px;\n                            padding: 2px 6px;\n                    \
      \    }\n                    \"\"\")\n\n        except Exception as e:\n    \
      \        print(f\"[messenger_gui] Error processing feedback: {e}\")\n\n"
    affinity: ''
    alias: User 2 GUI
    bg_image: '''/home/vboxuser/Downloads/tx.jpg'''
    comment: User 2 GUI
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Messenger GUI', 'messenger_gui', [('bg_image', "''")], [('feedback',
      'message', 1)], [('out', 'message', 1)], '\n    WhatsApp-style Messenger GUI
      with dynamic bubble resizing,\n    horizontal scroll for long messages, timestamp
      update on delivery,\n    and failure indication if retry limit is exceeded.\n    ',
      [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [144, 1472.0]
    rotation: 0
    state: disabled
- name: epy_block_0_2
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom gnuradio\
      \ import gr\nfrom PyQt5 import QtWidgets, QtCore, QtGui\nimport sys\nimport\
      \ pmt\nfrom datetime import datetime\n\nclass WallpaperScrollArea(QtWidgets.QScrollArea):\n\
      \    def __init__(self, bg_image=\"\", parent=None):\n        super().__init__(parent)\n\
      \        self.setWidgetResizable(True)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n\
      \        self.bg_pixmap = QtGui.QPixmap(bg_image) if bg_image else None\n\n\
      \    def paintEvent(self, event):\n        if self.bg_pixmap:\n            painter\
      \ = QtGui.QPainter(self.viewport())\n            painter.drawPixmap(self.viewport().rect(),\
      \ self.bg_pixmap)\n        super().paintEvent(event)\n\n\nclass _GuiPoster(QtCore.QObject):\n\
      \    \"\"\"Helper QObject to post strings into the Qt thread safely.\"\"\"\n\
      \    sig = QtCore.pyqtSignal(str)  # emits text payload\n\n    def __init__(self):\n\
      \        super().__init__()\n\n\nclass messenger_gui(gr.basic_block):\n    \"\
      \"\"\n    WhatsApp-style Messenger GUI (GNU Radio embedded block).\n    - Outgoing\
      \ messages: published on message port \"out\" with address prepended as \"addr:body\"\
      \n    - Feedback port \"feedback\": updates delivery timestamp / failed status\n\
      \    - Incoming messages: received on port \"in_msg\" (same format \"addr:body\"\
      ) and displayed\n      on the left in a different color.\n    \"\"\"\n\n   \
      \ def __init__(self, bg_image=\"\"):\n        gr.basic_block.__init__(\n   \
      \         self,\n            name=\"Messenger GUI\",\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n\n        # Message ports\n        self.message_port_register_out(pmt.intern(\"\
      out\"))    # outgoing messages\n        self.message_port_register_in(pmt.intern(\"\
      feedback\"))# delivery feedback\n        self.message_port_register_in(pmt.intern(\"\
      in_msg\"))  # incoming messages from remote/devices\n\n        # Bind handlers\n\
      \        self.set_msg_handler(pmt.intern(\"feedback\"), self._process_feedback)\n\
      \        self.set_msg_handler(pmt.intern(\"in_msg\"), self._receive_message)\n\
      \n        # Poster used to safely move messages to GUI thread\n        self._poster\
      \ = _GuiPoster()\n        self._poster.sig.connect(self._display_incoming) \
      \ # connect to GUI-thread handler\n\n        # Qt Application\n        self.app\
      \ = QtWidgets.QApplication.instance()\n        if self.app is None:\n      \
      \      self.app = QtWidgets.QApplication(sys.argv)\n\n        # Main window\n\
      \        self.qt_widget = QtWidgets.QWidget()\n        self.qt_widget.setWindowTitle(\"\
      Messenger GUI\")\n        self.qt_widget.resize(640, 560)\n\n        main_layout\
      \ = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(8, 8, 8,\
      \ 8)\n        main_layout.setSpacing(6)\n        self.qt_widget.setLayout(main_layout)\n\
      \n        # Address selection bar\n        addr_layout = QtWidgets.QHBoxLayout()\n\
      \        addr_label = QtWidgets.QLabel(\"To:\")\n        addr_label.setStyleSheet(\"\
      font-size: 18px; font-weight: bold;\")\n        addr_layout.addWidget(addr_label)\n\
      \n        self.addr_box = QtWidgets.QComboBox()\n        self.addr_box.addItems([str(i)\
      \ for i in range(1, 11)])  # 1..10 default\n        self.addr_box.setFixedWidth(100)\n\
      \        self.addr_box.setStyleSheet(\"font-size: 16px; padding: 4px;\")\n \
      \       addr_layout.addWidget(self.addr_box)\n        addr_layout.addStretch()\n\
      \n        main_layout.addLayout(addr_layout)\n\n        # Scroll area with background\n\
      \        self.scroll_area = WallpaperScrollArea(bg_image=bg_image)\n       \
      \ self.scroll_area.setStyleSheet(\"border: none;\")\n        self.scroll_area.setWidgetResizable(True)\n\
      \        main_layout.addWidget(self.scroll_area, stretch=1)\n\n        # Chat\
      \ container (vertical list of message widgets)\n        self.chat_container\
      \ = QtWidgets.QWidget()\n        self.chat_layout = QtWidgets.QVBoxLayout()\n\
      \        self.chat_layout.setAlignment(QtCore.Qt.AlignTop)\n        self.chat_layout.setSpacing(10)\n\
      \        self.chat_container.setLayout(self.chat_layout)\n        self.chat_container.setStyleSheet(\"\
      background: transparent;\")\n        self.scroll_area.setWidget(self.chat_container)\n\
      \n        # Input area (text entry + send)\n        input_layout = QtWidgets.QHBoxLayout()\n\
      \        self.input_box = QtWidgets.QLineEdit()\n        self.input_box.setPlaceholderText(\"\
      Type a message...\")\n        self.input_box.setMinimumHeight(40)\n        self.input_box.setStyleSheet(\"\
      \"\"\n            QLineEdit {\n                border-radius: 12px;\n      \
      \          padding: 8px;\n                background-color: rgba(255,255,255,0.95);\n\
      \                font-size: 16px;\n            }\n        \"\"\")\n        self.send_button\
      \ = QtWidgets.QPushButton(\"Send\")\n        self.send_button.setMinimumHeight(40)\n\
      \        self.send_button.setStyleSheet(\"\"\"\n            QPushButton {\n\
      \                background-color: #4CAF50;\n                color: white;\n\
      \                border-radius: 10px;\n                padding: 8px 16px;\n\
      \                font-weight: bold;\n                font-size: 16px;\n    \
      \        }\n            QPushButton:hover { background-color: #45a049; }\n \
      \       \"\"\")\n        input_layout.addWidget(self.input_box, stretch=1)\n\
      \        input_layout.addWidget(self.send_button, stretch=0)\n        main_layout.addLayout(input_layout)\n\
      \n        # Connect GUI signals\n        self.send_button.clicked.connect(self.send_message)\n\
      \        self.input_box.returnPressed.connect(self.send_message)\n\n       \
      \ # Track last sent message timestamp widget (simple approach)\n        # If\
      \ you want per-message tracking, change to a list/map of widgets per message\
      \ id.\n        self._last_message_timestamp = None\n\n        # show window\n\
      \        self.qt_widget.show()\n\n    def send_message(self):\n        \"\"\"\
      Called from GUI thread when user presses Send or Enter.\"\"\"\n        text\
      \ = self.input_box.text().strip()\n        if not text:\n            return\n\
      \n        addr = self.addr_box.currentText().strip()\n        full_msg = f\"\
      {addr}:{text}\"\n\n        # Publish as PMT symbol/string on 'out' port\n  \
      \      try:\n            self.message_port_pub(pmt.intern(\"out\"), pmt.intern(full_msg))\n\
      \        except Exception:\n            # fallback to generic intern\n     \
      \       self.message_port_pub(pmt.intern(\"out\"), pmt.intern(full_msg))\n\n\
      \        # Build outgoing bubble (right side)\n        container = QtWidgets.QWidget()\n\
      \        vbox = QtWidgets.QVBoxLayout()\n        vbox.setContentsMargins(0,\
      \ 0, 0, 0)\n        vbox.setSpacing(4)\n\n        # Scrollable area for long\
      \ messages\n        scroll = QtWidgets.QScrollArea()\n        scroll.setWidgetResizable(True)\n\
      \        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\
      \        scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       scroll.setFrameShape(QtWidgets.QFrame.NoFrame)\n        scroll.setStyleSheet(\"\
      background: transparent; border: none;\")\n\n        bubble = QtWidgets.QLabel(text)\
      \  # show only body (user-friendly)\n        bubble.setWordWrap(False)\n   \
      \     bubble.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)\n    \
      \    bubble.setStyleSheet(\"\"\"\n            QLabel {\n                background-color:\
      \ qlineargradient(x1:0,y1:0,x2:1,y2:1, stop:0 #4CAF50, stop:1 #66BB6A);\n  \
      \              color: white;\n                border-radius: 12px;\n       \
      \         padding: 8px 12px;\n                font-size: 14px;\n           \
      \ }\n        \"\"\")\n        # shadow\n        effect = QtWidgets.QGraphicsDropShadowEffect()\n\
      \        effect.setBlurRadius(6)\n        effect.setXOffset(2)\n        effect.setYOffset(2)\n\
      \        effect.setColor(QtGui.QColor(0, 0, 0, 80))\n        bubble.setGraphicsEffect(effect)\n\
      \n        scroll.setWidget(bubble)\n        scroll.setMinimumWidth(160)\n  \
      \      scroll.setMaximumWidth(520)\n\n        # Timestamp pill (initially 'Sending...')\n\
      \        timestamp = QtWidgets.QLabel(\"Sending...\")\n        timestamp.setStyleSheet(\"\
      \"\"\n            QLabel {\n                background-color: #2196F3;\n   \
      \             color: white;\n                font-size: 11px;\n            \
      \    border-radius: 8px;\n                padding: 2px 6px;\n            }\n\
      \        \"\"\")\n        timestamp.setAlignment(QtCore.Qt.AlignRight)\n   \
      \     timestamp.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n\
      \n        vbox.addWidget(scroll, alignment=QtCore.Qt.AlignRight)\n        vbox.addWidget(timestamp,\
      \ alignment=QtCore.Qt.AlignRight)\n        container.setLayout(vbox)\n     \
      \   container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)\n\
      \n        # Add to chat layout (right aligned)\n        self.chat_layout.addWidget(container,\
      \ alignment=QtCore.Qt.AlignRight)\n\n        # Force layout update and scroll\
      \ to bottom\n        bubble.adjustSize()\n        scroll.adjustSize()\n    \
      \    container.adjustSize()\n        self.chat_container.adjustSize()\n    \
      \    QtWidgets.QApplication.processEvents()\n        QtCore.QTimer.singleShot(20,\
      \ lambda: self.scroll_area.verticalScrollBar().setValue(\n            self.scroll_area.verticalScrollBar().maximum()\n\
      \        ))\n\n        # Clear input and store timestamp widget for feedback\
      \ updates\n        self.input_box.clear()\n        self._last_message_timestamp\
      \ = timestamp\n\n    def _process_feedback(self, msg_pmt):\n        \"\"\"\n\
      \        Handler for 'feedback' port. Expected feedback values:\n          -\
      \ \"TRUE\" => show delivery time\n          - \"FALSE\" => show 'Failed'\n \
      \       \"\"\"\n        try:\n            if pmt.is_symbol(msg_pmt) or pmt.is_string(msg_pmt):\n\
      \                fb = pmt.symbol_to_string(msg_pmt)\n            else:\n   \
      \             py = pmt.to_python(msg_pmt)\n                fb = str(py)\n  \
      \      except Exception:\n            fb = \"<unreadable feedback>\"\n\n   \
      \     print(fb)\n        # Update last timestamp widget if available (simple\
      \ single-last approach)\n        if self._last_message_timestamp:\n        \
      \    if fb == \"TRUE\":\n                self._last_message_timestamp.setText(datetime.now().strftime(\"\
      %H:%M:%S\"))\n                self._last_message_timestamp.setStyleSheet(\"\"\
      \"\n                    QLabel {\n                        background-color:\
      \ #2196F3;\n                        color: white;\n                        font-size:\
      \ 11px;\n                        border-radius: 8px;\n                     \
      \   padding: 2px 6px;\n                    }\n                \"\"\")\n    \
      \        elif fb == \"FALSE\":\n                self._last_message_timestamp.setText(\"\
      Failed\")\n                self._last_message_timestamp.setStyleSheet(\"\"\"\
      \n                    QLabel {\n                        background-color: #F44336;\n\
      \                        color: white;\n                        font-size: 11px;\n\
      \                        border-radius: 8px;\n                        padding:\
      \ 2px 6px;\n                    }\n                \"\"\")\n\n    def _receive_message(self,\
      \ msg_pmt):\n        \"\"\"\n        Handler for 'in_msg' port. Extracts string\
      \ and posts it to GUI thread\n        via _poster.sig so _display_incoming runs\
      \ in Qt thread.\n        \"\"\"\n        try:\n            if pmt.is_symbol(msg_pmt)\
      \ or pmt.is_string(msg_pmt):\n                s = pmt.symbol_to_string(msg_pmt)\n\
      \            else:\n                py = pmt.to_python(msg_pmt)\n          \
      \      s = str(py)\n        except Exception:\n            s = \"<unreadable\
      \ message>\"\n\n        # Post to GUI-thread handler\n        try:\n       \
      \     self._poster.sig.emit(s)\n        except Exception:\n            # If\
      \ signal emit fails for any reason, try direct call in case we're already in\
      \ Qt thread\n            try:\n                self._display_incoming(s)\n \
      \           except Exception:\n                print(\"[messenger_gui] failed\
      \ to deliver incoming message to GUI:\", s)\n\n    def _display_incoming(self,\
      \ full_msg):\n        \"\"\"\n        Build incoming bubble (left aligned).\
      \ full_msg expected in \"addr:body\" format.\n        \"\"\"\n        # try\
      \ to split \"addr:body\"\n        if \":\" in full_msg:\n            addr, body\
      \ = full_msg.split(\":\", 1)\n            display_text = f\"{body}\"\n     \
      \       header_text = f\"{addr}\"\n        else:\n            display_text =\
      \ full_msg\n            header_text = \"\"\n\n        container = QtWidgets.QWidget()\n\
      \        vbox = QtWidgets.QVBoxLayout()\n        vbox.setContentsMargins(0,\
      \ 0, 0, 0)\n        vbox.setSpacing(4)\n\n        scroll = QtWidgets.QScrollArea()\n\
      \        scroll.setWidgetResizable(True)\n        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\
      \        scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n \
      \       scroll.setFrameShape(QtWidgets.QFrame.NoFrame)\n        scroll.setStyleSheet(\"\
      background: transparent; border: none;\")\n\n        bubble = QtWidgets.QLabel(display_text)\n\
      \        bubble.setWordWrap(False)\n        bubble.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)\n\
      \        bubble.setStyleSheet(\"\"\"\n            QLabel {\n               \
      \ background-color: qlineargradient(x1:0,y1:0,x2:1,y2:1, stop:0 #E1F5FE, stop:1\
      \ #B3E5FC);\n                color: #0B2545;\n                border-radius:\
      \ 12px;\n                padding: 8px 12px;\n                font-size: 14px;\n\
      \            }\n        \"\"\")\n\n        # small header with sender address\
      \ (optional)\n        if header_text:\n            header = QtWidgets.QLabel(header_text)\n\
      \            header.setStyleSheet(\"font-size: 11px; color: #1565C0;\")\n  \
      \          header.setAlignment(QtCore.Qt.AlignLeft)\n            vbox.addWidget(header,\
      \ alignment=QtCore.Qt.AlignLeft)\n\n        scroll.setWidget(bubble)\n     \
      \   scroll.setMinimumWidth(160)\n        scroll.setMaximumWidth(520)\n\n   \
      \     vbox.addWidget(scroll, alignment=QtCore.Qt.AlignLeft)\n\n        # incoming\
      \ messages do not have delivery timestamp pill (feedback relates to outgoing)\n\
      \        container.setLayout(vbox)\n        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding,\
      \ QtWidgets.QSizePolicy.Fixed)\n\n        self.chat_layout.addWidget(container,\
      \ alignment=QtCore.Qt.AlignLeft)\n\n        # Update layout and scroll to bottom\n\
      \        bubble.adjustSize()\n        scroll.adjustSize()\n        container.adjustSize()\n\
      \        self.chat_container.adjustSize()\n        QtWidgets.QApplication.processEvents()\n\
      \        QtCore.QTimer.singleShot(20, lambda: self.scroll_area.verticalScrollBar().setValue(\n\
      \            self.scroll_area.verticalScrollBar().maximum()\n        ))\n"
    affinity: ''
    alias: ''
    bg_image: r"C:\Users\Oshan\Desktop\message.jpg"
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: '(''Messenger GUI'', ''messenger_gui'', [(''bg_image'', "''''")], [(''in_msg'',
      ''message'', 1), (''feedback'', ''message'', 1)], [(''out'', ''message'', 1)],
      ''\n    WhatsApp-style Messenger GUI (GNU Radio embedded block).\n    - Outgoing
      messages: published on message port "out" with address prepended as "addr:body"\n    -
      Feedback port "feedback": updates delivery timestamp / failed status\n    -
      Incoming messages: received on port "in_msg" (same format "addr:body") and displayed\n      on
      the left in a different color.\n    '', [])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [464, 1536.0]
    rotation: 180
    state: enabled
- name: pdu_pdu_to_tagged_stream_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: Header
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1112, 576.0]
    rotation: 0
    state: true
- name: pdu_pdu_to_tagged_stream_0_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: Payload
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1112, 704.0]
    rotation: 0
    state: true
- name: pdu_pdu_to_tagged_stream_0_0_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: Header
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1136, 1248.0]
    rotation: 0
    state: true
- name: pdu_pdu_to_tagged_stream_0_1
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: Payload
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1136, 1400.0]
    rotation: 0
    state: true
- name: pdu_tagged_stream_to_pdu_0_0
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [464, 1048.0]
    rotation: 180
    state: true
- name: pdu_tagged_stream_to_pdu_0_0_0
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [440, 368.0]
    rotation: 180
    state: true
- name: soapy_bladerf_sink_0
  id: soapy_bladerf_sink
  parameters:
    affinity: ''
    alias: ''
    bandwidth: 10e3
    center_freq: freq1
    comment: User 1 TX
    dev_args: ''
    freq_correction: '0'
    gain: '20.0'
    samp_rate: samp_rate
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2000, 636.0]
    rotation: 0
    state: enabled
- name: soapy_bladerf_sink_0_0
  id: soapy_bladerf_sink
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '0.0'
    center_freq: freq2
    comment: User 2 TX
    dev_args: ''
    freq_correction: '0'
    gain: '20.0'
    samp_rate: samp_rate
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2040, 1324.0]
    rotation: 0
    state: enabled
- name: soapy_bladerf_source_0
  id: soapy_bladerf_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '0.0'
    center_freq: freq2
    comment: User 1 RX
    dev_args: ''
    freq_correction: '0'
    gain: '20.0'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3184, 468.0]
    rotation: 180
    state: enabled
- name: soapy_bladerf_source_0_0
  id: soapy_bladerf_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: 10e3
    center_freq: freq1
    comment: User 2 RX
    dev_args: ''
    freq_correction: '0'
    gain: '20.0'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3256, 1148.0]
    rotation: 180
    state: enabled

connections:
- [blocks_message_strobe_0, strobe, epy_block_0, msg_in]
- [blocks_message_strobe_0_0, strobe, epy_block_0_0, msg_in]
- [blocks_repack_bits_bb_1_0_0, '0', pdu_tagged_stream_to_pdu_0_0, '0']
- [blocks_repack_bits_bb_1_0_0_0, '0', pdu_tagged_stream_to_pdu_0_0_0, '0']
- [blocks_tagged_stream_mux_0, '0', digital_constellation_modulator_0_0, '0']
- [blocks_tagged_stream_mux_0_0, '0', digital_constellation_modulator_0_0_0, '0']
- [blocks_unpack_k_bits_bb_0, '0', digital_correlate_access_code_xx_ts_0, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', digital_correlate_access_code_xx_ts_0_0, '0']
- [digital_constellation_decoder_cb_0_1, '0', digital_diff_decoder_bb_0_1, '0']
- [digital_constellation_decoder_cb_0_1_0, '0', digital_diff_decoder_bb_0_1_0, '0']
- [digital_constellation_modulator_0_0, '0', soapy_bladerf_sink_0, '0']
- [digital_constellation_modulator_0_0_0, '0', soapy_bladerf_sink_0_0, '0']
- [digital_correlate_access_code_xx_ts_0, '0', blocks_repack_bits_bb_1_0_0, '0']
- [digital_correlate_access_code_xx_ts_0_0, '0', blocks_repack_bits_bb_1_0_0_0, '0']
- [digital_costas_loop_cc_0_1, '0', digital_constellation_decoder_cb_0_1, '0']
- [digital_costas_loop_cc_0_1_0, '0', digital_constellation_decoder_cb_0_1_0, '0']
- [digital_diff_decoder_bb_0_1, '0', digital_map_bb_0_1, '0']
- [digital_diff_decoder_bb_0_1_0, '0', digital_map_bb_0_1_0, '0']
- [digital_linear_equalizer_0, '0', digital_costas_loop_cc_0_1_0, '0']
- [digital_linear_equalizer_0_0, '0', digital_costas_loop_cc_0_1, '0']
- [digital_map_bb_0_1, '0', blocks_unpack_k_bits_bb_0, '0']
- [digital_map_bb_0_1_0, '0', blocks_unpack_k_bits_bb_0_0, '0']
- [digital_pfb_clock_sync_xxx_0, '0', digital_linear_equalizer_0, '0']
- [digital_pfb_clock_sync_xxx_0_0, '0', digital_linear_equalizer_0_0, '0']
- [digital_protocol_formatter_async_0, header, pdu_pdu_to_tagged_stream_0, pdus]
- [digital_protocol_formatter_async_0, payload, pdu_pdu_to_tagged_stream_0_0, pdus]
- [digital_protocol_formatter_async_0_0, header, pdu_pdu_to_tagged_stream_0_0_0, pdus]
- [digital_protocol_formatter_async_0_0, payload, pdu_pdu_to_tagged_stream_0_1, pdus]
- [epy_block_0, feedback, epy_block_0_1, feedback]
- [epy_block_0, msg_out, blocks_message_debug_0_0, print]
- [epy_block_0, msg_out, epy_block_0_1, in_msg]
- [epy_block_0, pdu_out, digital_protocol_formatter_async_0, in]
- [epy_block_0_0, feedback, epy_block_0_2, feedback]
- [epy_block_0_0, msg_out, blocks_message_debug_0, print]
- [epy_block_0_0, msg_out, epy_block_0_2, in_msg]
- [epy_block_0_0, pdu_out, digital_protocol_formatter_async_0_0, in]
- [epy_block_0_1, out, epy_block_0, msg_in]
- [epy_block_0_1_0, out, epy_block_0, msg_in]
- [epy_block_0_1_0_0, out, epy_block_0_0, msg_in]
- [epy_block_0_2, out, epy_block_0_0, msg_in]
- [pdu_pdu_to_tagged_stream_0, '0', blocks_tagged_stream_mux_0, '0']
- [pdu_pdu_to_tagged_stream_0_0, '0', blocks_tagged_stream_mux_0, '1']
- [pdu_pdu_to_tagged_stream_0_0_0, '0', blocks_tagged_stream_mux_0_0, '0']
- [pdu_pdu_to_tagged_stream_0_1, '0', blocks_tagged_stream_mux_0_0, '1']
- [pdu_tagged_stream_to_pdu_0_0, pdus, epy_block_0_0, pdu_in]
- [pdu_tagged_stream_to_pdu_0_0_0, pdus, epy_block_0, pdu_in]
- [soapy_bladerf_source_0, '0', digital_pfb_clock_sync_xxx_0, '0']
- [soapy_bladerf_source_0_0, '0', digital_pfb_clock_sync_xxx_0_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
